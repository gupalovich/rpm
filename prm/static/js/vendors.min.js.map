{"version":3,"sources":["htmx.js","debug.js"],"names":["root","factory","define","amd","module","exports","htmx","self","this","onLoad","onLoadHelper","process","processNode","on","addEventListenerImpl","off","removeEventListenerImpl","trigger","triggerEvent","ajax","ajaxHelper","find","findAll","closest","values","elt","type","getInputValues","remove","removeElement","addClass","addClassToElement","removeClass","removeClassFromElement","toggleClass","toggleClassOnElement","takeClass","takeClassForElement","defineExtension","removeExtension","logAll","logger","config","historyEnabled","historyCacheSize","refreshOnHistoryMiss","defaultSwapStyle","defaultSwapDelay","defaultSettleDelay","includeIndicatorStyles","indicatorClass","requestClass","addedClass","settlingClass","swappingClass","allowEval","inlineScriptNonce","attributesToSettle","withCredentials","timeout","wsReconnectDelay","wsBinaryType","disableSelector","useTemplateFragments","scrollBehavior","defaultFocusScroll","getCacheBusterParam","parseInterval","_","internalEval","createEventSource","url","EventSource","createWebSocket","sock","WebSocket","binaryType","version","internalAPI","addTriggerHandler","bodyContains","canAccessLocalStorage","filterValues","hasAttribute","getAttributeValue","getClosestMatch","getExpressionVars","getHeaders","getInternalData","getSwapSpecification","getTriggerSpecs","getTarget","makeFragment","mergeObjects","makeSettleInfo","oobSwap","selectAndSwap","settleImmediately","shouldCancel","triggerErrorEvent","withExtensions","VERBS","VERB_SELECTOR","map","verb","join","str","undefined","slice","parseFloat","getRawAttribute","name","getAttribute","qualifiedName","parentElt","parentElement","getDocument","document","condition","getAttributeValueWithDisinheritance","initialElement","ancestor","attributeName","attributeValue","disinherit","split","indexOf","getClosestAttributeValue","closestAttr","e","matches","selector","matchesFunction","matchesSelector","msMatchesSelector","mozMatchesSelector","webkitMatchesSelector","oMatchesSelector","call","getStartTag","match","exec","toLowerCase","parseHTML","resp","depth","responseNode","DOMParser","parseFromString","body","firstChild","createDocumentFragment","querySelector","content","maybeCall","func","isType","o","Object","prototype","toString","isFunction","isRawObject","dataProp","data","toArray","arr","returnArr","i","length","push","forEach","isScrolledIntoView","el","rect","getBoundingClientRect","elemTop","top","elemBottom","bottom","window","innerHeight","getRootNode","ShadowRoot","contains","host","splitOnWhitespace","trim","obj1","obj2","key","hasOwnProperty","parseJSON","jString","JSON","parse","error","logError","test","localStorage","setItem","removeItem","maybeEval","eval","callback","evt","detail","event","console","log","eltOrSelector","querySelectorAll","delay","resolveTarget","setTimeout","removeChild","clazz","classList","add","removeAttribute","toggle","children","child","querySelectorAllExt","substr","scanForwardQuery","scanBackwardsQuery","start","results","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","querySelectorExt","arg2","processEventArgs","arg1","arg3","target","listener","ready","eventArgs","addEventListener","removeEventListener","DUMMY_ELT","createElement","findAttributeTargets","attrName","attrTarget","findThisElement","result","attribute","targetStr","boosted","shouldSettleAttribute","cloneAttributes","mergeTo","mergeFrom","attributes","attr","setAttribute","value","isInlineSwap","swapStyle","extensions","getExtensions","extension","oobValue","oobElement","settleInfo","id","targets","fragment","oobElementClone","cloneNode","appendChild","beforeSwapDetails","shouldSwap","swap","elts","parentNode","handleOutOfBandSwaps","oobSelects","oobSelectValues","oobSelectValue","substring","handlePreservedElements","preservedElt","oldElt","getElementById","replaceChild","handleAttributes","newNode","normalizedId","replace","oldNode","tagName","newAttributes","tasks","makeAjaxLoadTask","processScripts","processFocus","autofocus","autoFocusedElt","focus","insertNodesBefore","insertBefore","childNodes","nodeType","TEXT_NODE","COMMENT_NODE","stringHash","string","hash","char","charCodeAt","attributeHash","deInitNode","element","internalData","webSocket","close","sseEventSource","listenerInfos","info","cleanUpElement","swapOuterHTML","swapInnerHTML","newElt","eltBeforeNewContent","previousSibling","nextSibling","replacedWith","ELEMENT_NODE","nextElementSibling","swapAfterBegin","swapBeforeBegin","swapBeforeEnd","swapAfterEnd","swapDelete","maybeSelectFromResponse","newFragment","node","ext","newElements","handleSwap","j","findTitle","responseText","title","handleTrigger","xhr","header","triggerBody","getResponseHeader","triggers","eventName","WHITESPACE","WHITESPACE_OR_COMMA","SYMBOL_START","SYMBOL_CONT","STRINGISH_START","NOT_WHITESPACE","tokenizeString","tokens","position","charAt","startPosition","startChar","symbol","isPossibleRelativeReference","token","last","paramName","maybeGenerateConditional","shift","bracketCount","conditionalSource","conditionFunction","Function","source","consumeUntil","INPUT_SELECTOR","explicitTrigger","triggerSpecs","initialLength","every","pollInterval","eventFilter","sseEvent","triggerSpec","changed","once","consume","from_arg","from","throttle","queue","cancelPolling","cancelled","processPolling","handler","spec","nodeData","maybeFilterEvent","makeEvent","isLocalLink","location","hostname","boostElement","path","rawAttribute","issueAjaxRequest","href","ignoreBoostedAnchorCtrlClick","ctrlKey","metaKey","explicitCancel","eltsToListenOn","elementData","lastValue","eltToListenOn","eventListener","preventDefault","eventData","handledFor","stopPropagation","triggeredOnce","delayed","clearTimeout","windowIsScrolling","scrollHandler","initScrollHandler","setInterval","maybeReveal","initHash","processWebSocketInfo","ensureWebSocket","processWebSocketSend","wssSource","retryCount","base_part","port","protocol","socket","onerror","maybeCloseWebSocketSource","onclose","code","getWebSocketReconnectDelay","onopen","response","transformResponse","webSocketSourceElt","parent","headers","errors","filteredParameters","send","stringify","exp","Math","min","pow","random","processSSEInfo","processSSESource","processSSESwap","sseSrc","maybeCloseSSESource","sseEventName","sseSourceElt","hasEventSource","sseListener","swapSpec","processSSETrigger","loadImmediately","load","loaded","processVerbs","explicitAction","observerOptions","threshold","IntersectionObserver","entries","isIntersecting","observe","polling","evalScript","script","newScript","textContent","async","nonce","hasChanceOfBeingBoosted","findElementsToProcess","boostedElts","initButtonTracking","form","maybeSetLastButtonClicked","lastButtonClicked","initNode","sseInfo","wsInfo","kebabEventName","CustomEvent","bubbles","cancelable","createEvent","initCustomEvent","ignoreEventForLogging","toDo","msg","errorInfo","eventResult","dispatchEvent","kebabName","kebabedEvent","onEvent","currentPathForHistory","pathname","search","getHistoryElement","saveToHistoryCache","scroll","historyCache","getItem","splice","newHistoryItem","item","cache","cause","getCachedHistory","cleanInnerHtmlForHistory","className","clone","innerHTML","saveCurrentPageToHistory","historyElt","scrollY","history","replaceState","pushUrlIntoHistory","endsWith","pushState","replaceUrlInHistory","task","loadHistoryFromServer","request","XMLHttpRequest","details","open","setRequestHeader","onload","status","historyElement","titleElt","cacheMiss","serverResponse","restoreHistory","cached","scrollTo","reload","addRequestIndicatorClasses","indicators","ic","requestCount","removeRequestIndicatorClasses","haveSeenNode","processed","isSameNode","shouldInclude","disabled","checked","processInputValue","validate","multiple","files","current","Array","isArray","concat","validateElement","elements","input","willValidate","checkValidity","message","validationMessage","validity","formValues","noValidate","formNoValidate","descendant","appendParam","returnStr","realValue","String","s","encodeURIComponent","urlEncode","v","makeFormData","formData","FormData","append","prompt","getValuesForElement","inputValues","paramsValue","newValues","isAnchorLink","swapInfoOverride","swapInfo","swapDelay","settleDelay","modifier","scrollVal","splitSpec","pop","selectorVal","showVal","focusScrollVal","usesFormData","encodeParamsForBody","encodedParameters","encodeParameters","updateScrollState","first","scrollTarget","scrollTop","scrollHeight","show","showTarget","scrollIntoView","block","behavior","evalAsDefault","varsValues","evaluateValue","toEval","defaultVal","getHXVarsForElement","expressionVars","getHXValsForElement","safelySetHeaderValue","headerValue","getPathFromResponse","responseURL","URL","hasHeader","regexp","getAllResponseHeaders","context","Element","targetOverride","returnPromise","swapOverride","hierarchyForElt","etc","confirmed","resolve","reject","Promise","promise","_resolve","_reject","responseHandler","handleAjaxResponse","triggeringEvent","issueRequest","syncElt","eltData","syncStrategy","queueStrategy","abortable","syncStrings","queuedRequests","endRequestLock","queuedRequest","promptQuestion","promptResponse","confirmQuestion","confirm","rawParameters","allParameters","requestAttrValues","eltIsBoosted","requestConfig","parameters","unfilteredParameters","credentials","splitPath","pathNoAnchor","anchor","finalPathForGet","keys","toUpperCase","overrideMimeType","noHeaders","responseInfo","pathInfo","requestPath","finalRequestPath","hierarchy","responsePath","secondaryTriggerElt","parentEltInHierarchy","onabort","ontimeout","upload","lengthComputable","total","determineHistoryUpdates","pathFromHeaders","typeFromHeaders","pushUrl","replaceUrl","elementIsBoosted","saveType","redirectPath","then","historyUpdate","isError","failed","successful","doSwap","activeElt","activeElement","selectionInfo","selectionStart","end","selectionEnd","newActiveElt","focusOptions","preventScroll","focusScroll","setSelectionRange","finalElt","doSettle","anchorTarget","extensionBase","init","api","text","extensionsToReturn","extensionsToIgnore","extensionsForElement","extensionName","fn","readyState","insertIndicatorStyles","head","insertAdjacentHTML","getMetaConfig","mergeMetaConfig","metaConfig","restoredElts","abort","onpopstate","state","debug"],"mappings":"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","file":"vendors.min.js","sourcesContent":["// UMD insanity\n// This code sets up support for (in order) AMD, ES6 modules, and globals.\n(function (root, factory) {\n    //@ts-ignore\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        //@ts-ignore\n        define([], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals\n        root.htmx = root.htmx || factory();\n    }\n}(typeof self !== 'undefined' ? self : this, function () {\nreturn (function () {\n        'use strict';\n\n        // Public API\n        //** @type {import(\"./htmx\").HtmxApi} */\n        // TODO: list all methods in public API\n        var htmx = {\n            onLoad: onLoadHelper,\n            process: processNode,\n            on: addEventListenerImpl,\n            off: removeEventListenerImpl,\n            trigger : triggerEvent,\n            ajax : ajaxHelper,\n            find : find,\n            findAll : findAll,\n            closest : closest,\n            values : function(elt, type){\n                var inputValues = getInputValues(elt, type || \"post\");\n                return inputValues.values;\n            },\n            remove : removeElement,\n            addClass : addClassToElement,\n            removeClass : removeClassFromElement,\n            toggleClass : toggleClassOnElement,\n            takeClass : takeClassForElement,\n            defineExtension : defineExtension,\n            removeExtension : removeExtension,\n            logAll : logAll,\n            logger : null,\n            config : {\n                historyEnabled:true,\n                historyCacheSize:10,\n                refreshOnHistoryMiss:false,\n                defaultSwapStyle:'innerHTML',\n                defaultSwapDelay:0,\n                defaultSettleDelay:20,\n                includeIndicatorStyles:true,\n                indicatorClass:'htmx-indicator',\n                requestClass:'htmx-request',\n                addedClass:'htmx-added',\n                settlingClass:'htmx-settling',\n                swappingClass:'htmx-swapping',\n                allowEval:true,\n                inlineScriptNonce:'',\n                attributesToSettle:[\"class\", \"style\", \"width\", \"height\"],\n                withCredentials:false,\n                timeout:0,\n                wsReconnectDelay: 'full-jitter',\n                wsBinaryType: 'blob',\n                disableSelector: \"[hx-disable], [data-hx-disable]\",\n                useTemplateFragments: false,\n                scrollBehavior: 'smooth',\n                defaultFocusScroll: false,\n                getCacheBusterParam: false,\n            },\n            parseInterval:parseInterval,\n            _:internalEval,\n            createEventSource: function(url){\n                return new EventSource(url, {withCredentials:true})\n            },\n            createWebSocket: function(url){\n                var sock = new WebSocket(url, []);\n                sock.binaryType = htmx.config.wsBinaryType;\n                return sock;\n            },\n            version: \"1.8.6\"\n        };\n\n        /** @type {import(\"./htmx\").HtmxInternalApi} */\n        var internalAPI = {\n            addTriggerHandler: addTriggerHandler,\n            bodyContains: bodyContains,\n            canAccessLocalStorage: canAccessLocalStorage,\n            filterValues: filterValues,\n            hasAttribute: hasAttribute,\n            getAttributeValue: getAttributeValue,\n            getClosestMatch: getClosestMatch,\n            getExpressionVars: getExpressionVars,\n            getHeaders: getHeaders,\n            getInputValues: getInputValues,\n            getInternalData: getInternalData,\n            getSwapSpecification: getSwapSpecification,\n            getTriggerSpecs: getTriggerSpecs,\n            getTarget: getTarget,\n            makeFragment: makeFragment,\n            mergeObjects: mergeObjects,\n            makeSettleInfo: makeSettleInfo,\n            oobSwap: oobSwap,\n            selectAndSwap: selectAndSwap,\n            settleImmediately: settleImmediately,\n            shouldCancel: shouldCancel,\n            triggerEvent: triggerEvent,\n            triggerErrorEvent: triggerErrorEvent,\n            withExtensions: withExtensions,\n        }\n\n        var VERBS = ['get', 'post', 'put', 'delete', 'patch'];\n        var VERB_SELECTOR = VERBS.map(function(verb){\n            return \"[hx-\" + verb + \"], [data-hx-\" + verb + \"]\"\n        }).join(\", \");\n\n        //====================================================================\n        // Utilities\n        //====================================================================\n\n        function parseInterval(str) {\n            if (str == undefined)  {\n                return undefined\n            }\n            if (str.slice(-2) == \"ms\") {\n                return parseFloat(str.slice(0,-2)) || undefined\n            }\n            if (str.slice(-1) == \"s\") {\n                return (parseFloat(str.slice(0,-1)) * 1000) || undefined\n            }\n            if (str.slice(-1) == \"m\") {\n                return (parseFloat(str.slice(0,-1)) * 1000 * 60) || undefined\n            }\n            return parseFloat(str) || undefined\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {string} name\n         * @returns {(string | null)}\n         */\n        function getRawAttribute(elt, name) {\n            return elt.getAttribute && elt.getAttribute(name);\n        }\n\n        // resolve with both hx and data-hx prefixes\n        function hasAttribute(elt, qualifiedName) {\n            return elt.hasAttribute && (elt.hasAttribute(qualifiedName) ||\n                elt.hasAttribute(\"data-\" + qualifiedName));\n        }\n\n        /**\n         *\n         * @param {HTMLElement} elt\n         * @param {string} qualifiedName\n         * @returns {(string | null)}\n         */\n        function getAttributeValue(elt, qualifiedName) {\n            return getRawAttribute(elt, qualifiedName) || getRawAttribute(elt, \"data-\" + qualifiedName);\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @returns {HTMLElement | null}\n         */\n        function parentElt(elt) {\n            return elt.parentElement;\n        }\n\n        /**\n         * @returns {Document}\n         */\n        function getDocument() {\n            return document;\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {(e:HTMLElement) => boolean} condition\n         * @returns {HTMLElement | null}\n         */\n        function getClosestMatch(elt, condition) {\n            while (elt && !condition(elt)) {\n                elt = parentElt(elt);\n            }\n\n            return elt ? elt : null;\n        }\n\n        function getAttributeValueWithDisinheritance(initialElement, ancestor, attributeName){\n            var attributeValue = getAttributeValue(ancestor, attributeName);\n            var disinherit = getAttributeValue(ancestor, \"hx-disinherit\");\n            if (initialElement !== ancestor && disinherit && (disinherit === \"*\" || disinherit.split(\" \").indexOf(attributeName) >= 0)) {\n                return \"unset\";\n            } else {\n                return attributeValue\n            }\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {string} attributeName\n         * @returns {string | null}\n         */\n        function getClosestAttributeValue(elt, attributeName) {\n            var closestAttr = null;\n            getClosestMatch(elt, function (e) {\n                return closestAttr = getAttributeValueWithDisinheritance(elt, e, attributeName);\n            });\n            if (closestAttr !== \"unset\") {\n                return closestAttr;\n            }\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {string} selector\n         * @returns {boolean}\n         */\n        function matches(elt, selector) {\n            // @ts-ignore: non-standard properties for browser compatability\n            // noinspection JSUnresolvedVariable\n            var matchesFunction = elt.matches || elt.matchesSelector || elt.msMatchesSelector || elt.mozMatchesSelector || elt.webkitMatchesSelector || elt.oMatchesSelector;\n            return matchesFunction && matchesFunction.call(elt, selector);\n        }\n\n        /**\n         * @param {string} str\n         * @returns {string}\n         */\n        function getStartTag(str) {\n            var tagMatcher = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i\n            var match = tagMatcher.exec( str );\n            if (match) {\n                return match[1].toLowerCase();\n            } else {\n                return \"\";\n            }\n        }\n\n        /**\n         *\n         * @param {string} resp\n         * @param {number} depth\n         * @returns {Element}\n         */\n        function parseHTML(resp, depth) {\n            var parser = new DOMParser();\n            var responseDoc = parser.parseFromString(resp, \"text/html\");\n\n            /** @type {Element} */\n            var responseNode = responseDoc.body;\n            while (depth > 0) {\n                depth--;\n                // @ts-ignore\n                responseNode = responseNode.firstChild;\n            }\n            if (responseNode == null) {\n                // @ts-ignore\n                responseNode = getDocument().createDocumentFragment();\n            }\n            return responseNode;\n        }\n\n        /**\n         *\n         * @param {string} resp\n         * @returns {Element}\n         */\n        function makeFragment(resp) {\n            if (htmx.config.useTemplateFragments) {\n                var documentFragment = parseHTML(\"<body><template>\" + resp + \"</template></body>\", 0);\n                // @ts-ignore type mismatch between DocumentFragment and Element.\n                // TODO: Are these close enough for htmx to use interchangably?\n                return documentFragment.querySelector('template').content;\n            } else {\n                var startTag = getStartTag(resp);\n                switch (startTag) {\n                    case \"thead\":\n                    case \"tbody\":\n                    case \"tfoot\":\n                    case \"colgroup\":\n                    case \"caption\":\n                        return parseHTML(\"<table>\" + resp + \"</table>\", 1);\n                    case \"col\":\n                        return parseHTML(\"<table><colgroup>\" + resp + \"</colgroup></table>\", 2);\n                    case \"tr\":\n                        return parseHTML(\"<table><tbody>\" + resp + \"</tbody></table>\", 2);\n                    case \"td\":\n                    case \"th\":\n                        return parseHTML(\"<table><tbody><tr>\" + resp + \"</tr></tbody></table>\", 3);\n                    case \"script\":\n                        return parseHTML(\"<div>\" + resp + \"</div>\", 1);\n                    default:\n                        return parseHTML(resp, 0);\n                }\n            }\n        }\n\n        /**\n         * @param {Function} func\n         */\n        function maybeCall(func){\n            if(func) {\n                func();\n            }\n        }\n\n        /**\n         * @param {any} o\n         * @param {string} type\n         * @returns\n         */\n        function isType(o, type) {\n            return Object.prototype.toString.call(o) === \"[object \" + type + \"]\";\n        }\n\n        /**\n         * @param {*} o\n         * @returns {o is Function}\n         */\n        function isFunction(o) {\n            return isType(o, \"Function\");\n        }\n\n        /**\n         * @param {*} o\n         * @returns {o is Object}\n         */\n        function isRawObject(o) {\n            return isType(o, \"Object\");\n        }\n\n        /**\n         * getInternalData retrieves \"private\" data stored by htmx within an element\n         * @param {HTMLElement} elt\n         * @returns {*}\n         */\n        function getInternalData(elt) {\n            var dataProp = 'htmx-internal-data';\n            var data = elt[dataProp];\n            if (!data) {\n                data = elt[dataProp] = {};\n            }\n            return data;\n        }\n\n        /**\n         * toArray converts an ArrayLike object into a real array.\n         * @param {ArrayLike} arr\n         * @returns {any[]}\n         */\n        function toArray(arr) {\n            var returnArr = [];\n            if (arr) {\n                for (var i = 0; i < arr.length; i++) {\n                    returnArr.push(arr[i]);\n                }\n            }\n            return returnArr\n        }\n\n        function forEach(arr, func) {\n            if (arr) {\n                for (var i = 0; i < arr.length; i++) {\n                    func(arr[i]);\n                }\n            }\n        }\n\n        function isScrolledIntoView(el) {\n            var rect = el.getBoundingClientRect();\n            var elemTop = rect.top;\n            var elemBottom = rect.bottom;\n            return elemTop < window.innerHeight && elemBottom >= 0;\n        }\n\n        function bodyContains(elt) {\n            // IE Fix\n            if (elt.getRootNode && elt.getRootNode() instanceof ShadowRoot) {\n                return getDocument().body.contains(elt.getRootNode().host);\n            } else {\n                return getDocument().body.contains(elt);\n            }\n        }\n\n        function splitOnWhitespace(trigger) {\n            return trigger.trim().split(/\\s+/);\n        }\n\n        /**\n         * mergeObjects takes all of the keys from\n         * obj2 and duplicates them into obj1\n         * @param {Object} obj1\n         * @param {Object} obj2\n         * @returns {Object}\n         */\n        function mergeObjects(obj1, obj2) {\n            for (var key in obj2) {\n                if (obj2.hasOwnProperty(key)) {\n                    obj1[key] = obj2[key];\n                }\n            }\n            return obj1;\n        }\n\n        function parseJSON(jString) {\n            try {\n                return JSON.parse(jString);\n            } catch(error) {\n                logError(error);\n                return null;\n            }\n        }\n\n        function canAccessLocalStorage() {\n            var test = 'htmx:localStorageTest';\n            try {\n                localStorage.setItem(test, test);\n                localStorage.removeItem(test);\n                return true;\n            } catch(e) {\n                return false;\n            }\n        }\n\n        //==========================================================================================\n        // public API\n        //==========================================================================================\n\n        function internalEval(str){\n            return maybeEval(getDocument().body, function () {\n                return eval(str);\n            });\n        }\n\n        function onLoadHelper(callback) {\n            var value = htmx.on(\"htmx:load\", function(evt) {\n                callback(evt.detail.elt);\n            });\n            return value;\n        }\n\n        function logAll(){\n            htmx.logger = function(elt, event, data) {\n                if(console) {\n                    console.log(event, elt, data);\n                }\n            }\n        }\n\n        function find(eltOrSelector, selector) {\n            if (selector) {\n                return eltOrSelector.querySelector(selector);\n            } else {\n                return find(getDocument(), eltOrSelector);\n            }\n        }\n\n        function findAll(eltOrSelector, selector) {\n            if (selector) {\n                return eltOrSelector.querySelectorAll(selector);\n            } else {\n                return findAll(getDocument(), eltOrSelector);\n            }\n        }\n\n        function removeElement(elt, delay) {\n            elt = resolveTarget(elt);\n            if (delay) {\n                setTimeout(function(){removeElement(elt);}, delay)\n            } else {\n                elt.parentElement.removeChild(elt);\n            }\n        }\n\n        function addClassToElement(elt, clazz, delay) {\n            elt = resolveTarget(elt);\n            if (delay) {\n                setTimeout(function(){addClassToElement(elt, clazz);}, delay)\n            } else {\n                elt.classList && elt.classList.add(clazz);\n            }\n        }\n\n        function removeClassFromElement(elt, clazz, delay) {\n            elt = resolveTarget(elt);\n            if (delay) {\n                setTimeout(function(){removeClassFromElement(elt, clazz);}, delay)\n            } else {\n                if (elt.classList) {\n                    elt.classList.remove(clazz);\n                    // if there are no classes left, remove the class attribute\n                    if (elt.classList.length === 0) {\n                        elt.removeAttribute(\"class\");\n                    }\n                }\n            }\n        }\n\n        function toggleClassOnElement(elt, clazz) {\n            elt = resolveTarget(elt);\n            elt.classList.toggle(clazz);\n        }\n\n        function takeClassForElement(elt, clazz) {\n            elt = resolveTarget(elt);\n            forEach(elt.parentElement.children, function(child){\n                removeClassFromElement(child, clazz);\n            })\n            addClassToElement(elt, clazz);\n        }\n\n        function closest(elt, selector) {\n            elt = resolveTarget(elt);\n            if (elt.closest) {\n                return elt.closest(selector);\n            } else {\n                // TODO remove when IE goes away\n                do{\n                    if (elt == null || matches(elt, selector)){\n                        return elt;\n                    }\n                }\n                while (elt = elt && parentElt(elt));\n                return null;\n            }\n        }\n\n        function querySelectorAllExt(elt, selector) {\n            if (selector.indexOf(\"closest \") === 0) {\n                return [closest(elt, selector.substr(8))];\n            } else if (selector.indexOf(\"find \") === 0) {\n                return [find(elt, selector.substr(5))];\n            } else if (selector.indexOf(\"next \") === 0) {\n                return [scanForwardQuery(elt, selector.substr(5))];\n            } else if (selector.indexOf(\"previous \") === 0) {\n                return [scanBackwardsQuery(elt, selector.substr(9))];\n            } else if (selector === 'document') {\n                return [document];\n            } else if (selector === 'window') {\n                return [window];\n            } else {\n                return getDocument().querySelectorAll(selector);\n            }\n        }\n\n        var scanForwardQuery = function(start, match) {\n            var results = getDocument().querySelectorAll(match);\n            for (var i = 0; i < results.length; i++) {\n                var elt = results[i];\n                if (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_PRECEDING) {\n                    return elt;\n                }\n            }\n        }\n\n        var scanBackwardsQuery = function(start, match) {\n            var results = getDocument().querySelectorAll(match);\n            for (var i = results.length - 1; i >= 0; i--) {\n                var elt = results[i];\n                if (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_FOLLOWING) {\n                    return elt;\n                }\n            }\n        }\n\n        function querySelectorExt(eltOrSelector, selector) {\n            if (selector) {\n                return querySelectorAllExt(eltOrSelector, selector)[0];\n            } else {\n                return querySelectorAllExt(getDocument().body, eltOrSelector)[0];\n            }\n        }\n\n        function resolveTarget(arg2) {\n            if (isType(arg2, 'String')) {\n                return find(arg2);\n            } else {\n                return arg2;\n            }\n        }\n\n        function processEventArgs(arg1, arg2, arg3) {\n            if (isFunction(arg2)) {\n                return {\n                    target: getDocument().body,\n                    event: arg1,\n                    listener: arg2\n                }\n            } else {\n                return {\n                    target: resolveTarget(arg1),\n                    event: arg2,\n                    listener: arg3\n                }\n            }\n\n        }\n\n        function addEventListenerImpl(arg1, arg2, arg3) {\n            ready(function(){\n                var eventArgs = processEventArgs(arg1, arg2, arg3);\n                eventArgs.target.addEventListener(eventArgs.event, eventArgs.listener);\n            })\n            var b = isFunction(arg2);\n            return b ? arg2 : arg3;\n        }\n\n        function removeEventListenerImpl(arg1, arg2, arg3) {\n            ready(function(){\n                var eventArgs = processEventArgs(arg1, arg2, arg3);\n                eventArgs.target.removeEventListener(eventArgs.event, eventArgs.listener);\n            })\n            return isFunction(arg2) ? arg2 : arg3;\n        }\n\n        //====================================================================\n        // Node processing\n        //====================================================================\n\n        var DUMMY_ELT = getDocument().createElement(\"output\"); // dummy element for bad selectors\n        function findAttributeTargets(elt, attrName) {\n            var attrTarget = getClosestAttributeValue(elt, attrName);\n            if (attrTarget) {\n                if (attrTarget === \"this\") {\n                    return [findThisElement(elt, attrName)];\n                } else {\n                    var result = querySelectorAllExt(elt, attrTarget);\n                    if (result.length === 0) {\n                        logError('The selector \"' + attrTarget + '\" on ' + attrName + \" returned no matches!\");\n                        return [DUMMY_ELT]\n                    } else {\n                        return result;\n                    }\n                }\n            }\n        }\n\n        function findThisElement(elt, attribute){\n            return getClosestMatch(elt, function (elt) {\n                return getAttributeValue(elt, attribute) != null;\n            })\n        }\n\n        function getTarget(elt) {\n            var targetStr = getClosestAttributeValue(elt, \"hx-target\");\n            if (targetStr) {\n                if (targetStr === \"this\") {\n                    return findThisElement(elt,'hx-target');\n                } else {\n                    return querySelectorExt(elt, targetStr)\n                }\n            } else {\n                var data = getInternalData(elt);\n                if (data.boosted) {\n                    return getDocument().body;\n                } else {\n                    return elt;\n                }\n            }\n        }\n\n        function shouldSettleAttribute(name) {\n            var attributesToSettle = htmx.config.attributesToSettle;\n            for (var i = 0; i < attributesToSettle.length; i++) {\n                if (name === attributesToSettle[i]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        function cloneAttributes(mergeTo, mergeFrom) {\n            forEach(mergeTo.attributes, function (attr) {\n                if (!mergeFrom.hasAttribute(attr.name) && shouldSettleAttribute(attr.name)) {\n                    mergeTo.removeAttribute(attr.name)\n                }\n            });\n            forEach(mergeFrom.attributes, function (attr) {\n                if (shouldSettleAttribute(attr.name)) {\n                    mergeTo.setAttribute(attr.name, attr.value);\n                }\n            });\n        }\n\n        function isInlineSwap(swapStyle, target) {\n            var extensions = getExtensions(target);\n            for (var i = 0; i < extensions.length; i++) {\n                var extension = extensions[i];\n                try {\n                    if (extension.isInlineSwap(swapStyle)) {\n                        return true;\n                    }\n                } catch(e) {\n                    logError(e);\n                }\n            }\n            return swapStyle === \"outerHTML\";\n        }\n\n        /**\n         *\n         * @param {string} oobValue\n         * @param {HTMLElement} oobElement\n         * @param {*} settleInfo\n         * @returns\n         */\n        function oobSwap(oobValue, oobElement, settleInfo) {\n            var selector = \"#\" + oobElement.id;\n            var swapStyle = \"outerHTML\";\n            if (oobValue === \"true\") {\n                // do nothing\n            } else if (oobValue.indexOf(\":\") > 0) {\n                swapStyle = oobValue.substr(0, oobValue.indexOf(\":\"));\n                selector  = oobValue.substr(oobValue.indexOf(\":\") + 1, oobValue.length);\n            } else {\n                swapStyle = oobValue;\n            }\n\n            var targets = getDocument().querySelectorAll(selector);\n            if (targets) {\n                forEach(\n                    targets,\n                    function (target) {\n                        var fragment;\n                        var oobElementClone = oobElement.cloneNode(true);\n                        fragment = getDocument().createDocumentFragment();\n                        fragment.appendChild(oobElementClone);\n                        if (!isInlineSwap(swapStyle, target)) {\n                            fragment = oobElementClone; // if this is not an inline swap, we use the content of the node, not the node itself\n                        }\n\n                        var beforeSwapDetails = {shouldSwap: true, target: target, fragment:fragment };\n                        if (!triggerEvent(target, 'htmx:oobBeforeSwap', beforeSwapDetails)) return;\n\n                        target = beforeSwapDetails.target; // allow re-targeting\n                        if (beforeSwapDetails['shouldSwap']){\n                            swap(swapStyle, target, target, fragment, settleInfo);\n                        }\n                        forEach(settleInfo.elts, function (elt) {\n                            triggerEvent(elt, 'htmx:oobAfterSwap', beforeSwapDetails);\n                        });\n                    }\n                );\n                oobElement.parentNode.removeChild(oobElement);\n            } else {\n                oobElement.parentNode.removeChild(oobElement);\n                triggerErrorEvent(getDocument().body, \"htmx:oobErrorNoTarget\", {content: oobElement});\n            }\n            return oobValue;\n        }\n\n        function handleOutOfBandSwaps(elt, fragment, settleInfo) {\n            var oobSelects = getClosestAttributeValue(elt, \"hx-select-oob\");\n            if (oobSelects) {\n                var oobSelectValues = oobSelects.split(\",\");\n                for (let i = 0; i < oobSelectValues.length; i++) {\n                    var oobSelectValue = oobSelectValues[i].split(\":\", 2);\n                    var id = oobSelectValue[0];\n                    if (id.indexOf(\"#\") === 0) {\n                        id = id.substring(1);\n                    }\n                    var oobValue = oobSelectValue[1] || \"true\";\n                    var oobElement = fragment.querySelector(\"#\" + id);\n                    if (oobElement) {\n                        oobSwap(oobValue, oobElement, settleInfo);\n                    }\n                }\n            }\n            forEach(findAll(fragment, '[hx-swap-oob], [data-hx-swap-oob]'), function (oobElement) {\n                var oobValue = getAttributeValue(oobElement, \"hx-swap-oob\");\n                if (oobValue != null) {\n                    oobSwap(oobValue, oobElement, settleInfo);\n                }\n            });\n        }\n\n        function handlePreservedElements(fragment) {\n            forEach(findAll(fragment, '[hx-preserve], [data-hx-preserve]'), function (preservedElt) {\n                var id = getAttributeValue(preservedElt, \"id\");\n                var oldElt = getDocument().getElementById(id);\n                if (oldElt != null) {\n                    preservedElt.parentNode.replaceChild(oldElt, preservedElt);\n                }\n            });\n        }\n\n        function handleAttributes(parentNode, fragment, settleInfo) {\n            forEach(fragment.querySelectorAll(\"[id]\"), function (newNode) {\n                if (newNode.id && newNode.id.length > 0) {\n                    var normalizedId = newNode.id.replace(\"'\", \"\\\\'\");\n                    var oldNode = parentNode.querySelector(newNode.tagName + \"[id='\" + normalizedId + \"']\");\n                    if (oldNode && oldNode !== parentNode) {\n                        var newAttributes = newNode.cloneNode();\n                        cloneAttributes(newNode, oldNode);\n                        settleInfo.tasks.push(function () {\n                            cloneAttributes(newNode, newAttributes);\n                        });\n                    }\n                }\n            });\n        }\n\n        function makeAjaxLoadTask(child) {\n            return function () {\n                removeClassFromElement(child, htmx.config.addedClass);\n                processNode(child);\n                processScripts(child);\n                processFocus(child)\n                triggerEvent(child, 'htmx:load');\n            };\n        }\n\n        function processFocus(child) {\n            var autofocus = \"[autofocus]\";\n            var autoFocusedElt = matches(child, autofocus) ? child : child.querySelector(autofocus)\n            if (autoFocusedElt != null) {\n                autoFocusedElt.focus();\n            }\n        }\n\n        function insertNodesBefore(parentNode, insertBefore, fragment, settleInfo) {\n            handleAttributes(parentNode, fragment, settleInfo);\n            while(fragment.childNodes.length > 0){\n                var child = fragment.firstChild;\n                addClassToElement(child, htmx.config.addedClass);\n                parentNode.insertBefore(child, insertBefore);\n                if (child.nodeType !== Node.TEXT_NODE && child.nodeType !== Node.COMMENT_NODE) {\n                    settleInfo.tasks.push(makeAjaxLoadTask(child));\n                }\n            }\n        }\n\n        // based on https://gist.github.com/hyamamoto/fd435505d29ebfa3d9716fd2be8d42f0,\n        // derived from Java's string hashcode implementation\n        function stringHash(string, hash) {\n            var char = 0;\n            while (char < string.length){\n                hash = (hash << 5) - hash + string.charCodeAt(char++) | 0; // bitwise or ensures we have a 32-bit int\n            }\n            return hash;\n        }\n\n        function attributeHash(elt) {\n            var hash = 0;\n            // IE fix\n            if (elt.attributes) {\n                for (var i = 0; i < elt.attributes.length; i++) {\n                    var attribute = elt.attributes[i];\n                    if(attribute.value){ // only include attributes w/ actual values (empty is same as non-existent)\n                        hash = stringHash(attribute.name, hash);\n                        hash = stringHash(attribute.value, hash);\n                    }\n                }\n            }\n            return hash;\n        }\n\n        function deInitNode(element) {\n            var internalData = getInternalData(element);\n            if (internalData.webSocket) {\n                internalData.webSocket.close();\n            }\n            if (internalData.sseEventSource) {\n                internalData.sseEventSource.close();\n            }\n            if (internalData.listenerInfos) {\n                forEach(internalData.listenerInfos, function (info) {\n                    if (info.on) {\n                        info.on.removeEventListener(info.trigger, info.listener);\n                    }\n                });\n            }\n        }\n\n        function cleanUpElement(element) {\n            triggerEvent(element, \"htmx:beforeCleanupElement\")\n            deInitNode(element);\n            if (element.children) { // IE\n                forEach(element.children, function(child) { cleanUpElement(child) });\n            }\n        }\n\n        function swapOuterHTML(target, fragment, settleInfo) {\n            if (target.tagName === \"BODY\") {\n                return swapInnerHTML(target, fragment, settleInfo);\n            } else {\n                // @type {HTMLElement}\n                var newElt\n                var eltBeforeNewContent = target.previousSibling;\n                insertNodesBefore(parentElt(target), target, fragment, settleInfo);\n                if (eltBeforeNewContent == null) {\n                    newElt = parentElt(target).firstChild;\n                } else {\n                    newElt = eltBeforeNewContent.nextSibling;\n                }\n                getInternalData(target).replacedWith = newElt; // tuck away so we can fire events on it later\n                settleInfo.elts = [] // clear existing elements\n                while(newElt && newElt !== target) {\n                    if (newElt.nodeType === Node.ELEMENT_NODE) {\n                        settleInfo.elts.push(newElt);\n                    }\n                    newElt = newElt.nextElementSibling;\n                }\n                cleanUpElement(target);\n                parentElt(target).removeChild(target);\n            }\n        }\n\n        function swapAfterBegin(target, fragment, settleInfo) {\n            return insertNodesBefore(target, target.firstChild, fragment, settleInfo);\n        }\n\n        function swapBeforeBegin(target, fragment, settleInfo) {\n            return insertNodesBefore(parentElt(target), target, fragment, settleInfo);\n        }\n\n        function swapBeforeEnd(target, fragment, settleInfo) {\n            return insertNodesBefore(target, null, fragment, settleInfo);\n        }\n\n        function swapAfterEnd(target, fragment, settleInfo) {\n            return insertNodesBefore(parentElt(target), target.nextSibling, fragment, settleInfo);\n        }\n        function swapDelete(target, fragment, settleInfo) {\n            cleanUpElement(target);\n            return parentElt(target).removeChild(target);\n        }\n\n        function swapInnerHTML(target, fragment, settleInfo) {\n            var firstChild = target.firstChild;\n            insertNodesBefore(target, firstChild, fragment, settleInfo);\n            if (firstChild) {\n                while (firstChild.nextSibling) {\n                    cleanUpElement(firstChild.nextSibling)\n                    target.removeChild(firstChild.nextSibling);\n                }\n                cleanUpElement(firstChild)\n                target.removeChild(firstChild);\n            }\n        }\n\n        function maybeSelectFromResponse(elt, fragment) {\n            var selector = getClosestAttributeValue(elt, \"hx-select\");\n            if (selector) {\n                var newFragment = getDocument().createDocumentFragment();\n                forEach(fragment.querySelectorAll(selector), function (node) {\n                    newFragment.appendChild(node);\n                });\n                fragment = newFragment;\n            }\n            return fragment;\n        }\n\n        function swap(swapStyle, elt, target, fragment, settleInfo) {\n            switch (swapStyle) {\n                case \"none\":\n                    return;\n                case \"outerHTML\":\n                    swapOuterHTML(target, fragment, settleInfo);\n                    return;\n                case \"afterbegin\":\n                    swapAfterBegin(target, fragment, settleInfo);\n                    return;\n                case \"beforebegin\":\n                    swapBeforeBegin(target, fragment, settleInfo);\n                    return;\n                case \"beforeend\":\n                    swapBeforeEnd(target, fragment, settleInfo);\n                    return;\n                case \"afterend\":\n                    swapAfterEnd(target, fragment, settleInfo);\n                    return;\n                case \"delete\":\n                    swapDelete(target, fragment, settleInfo);\n                    return;\n                default:\n                    var extensions = getExtensions(elt);\n                    for (var i = 0; i < extensions.length; i++) {\n                        var ext = extensions[i];\n                        try {\n                            var newElements = ext.handleSwap(swapStyle, target, fragment, settleInfo);\n                            if (newElements) {\n                                if (typeof newElements.length !== 'undefined') {\n                                    // if handleSwap returns an array (like) of elements, we handle them\n                                    for (var j = 0; j < newElements.length; j++) {\n                                        var child = newElements[j];\n                                        if (child.nodeType !== Node.TEXT_NODE && child.nodeType !== Node.COMMENT_NODE) {\n                                            settleInfo.tasks.push(makeAjaxLoadTask(child));\n                                        }\n                                    }\n                                }\n                                return;\n                            }\n                        } catch (e) {\n                            logError(e);\n                        }\n                    }\n                    if (swapStyle === \"innerHTML\") {\n                        swapInnerHTML(target, fragment, settleInfo);\n                    } else {\n                        swap(htmx.config.defaultSwapStyle, elt, target, fragment, settleInfo);\n                    }\n            }\n        }\n\n        function findTitle(content) {\n            if (content.indexOf('<title') > -1) {\n                var contentWithSvgsRemoved = content.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '');\n                var result = contentWithSvgsRemoved.match(/<title(\\s[^>]*>|>)([\\s\\S]*?)<\\/title>/im);\n\n                if (result) {\n                    return result[2];\n                }\n            }\n        }\n\n        function selectAndSwap(swapStyle, target, elt, responseText, settleInfo) {\n            settleInfo.title = findTitle(responseText);\n            var fragment = makeFragment(responseText);\n            if (fragment) {\n                handleOutOfBandSwaps(elt, fragment, settleInfo);\n                fragment = maybeSelectFromResponse(elt, fragment);\n                handlePreservedElements(fragment);\n                return swap(swapStyle, elt, target, fragment, settleInfo);\n            }\n        }\n\n        function handleTrigger(xhr, header, elt) {\n            var triggerBody = xhr.getResponseHeader(header);\n            if (triggerBody.indexOf(\"{\") === 0) {\n                var triggers = parseJSON(triggerBody);\n                for (var eventName in triggers) {\n                    if (triggers.hasOwnProperty(eventName)) {\n                        var detail = triggers[eventName];\n                        if (!isRawObject(detail)) {\n                            detail = {\"value\": detail}\n                        }\n                        triggerEvent(elt, eventName, detail);\n                    }\n                }\n            } else {\n                triggerEvent(elt, triggerBody, []);\n            }\n        }\n\n        var WHITESPACE = /\\s/;\n        var WHITESPACE_OR_COMMA = /[\\s,]/;\n        var SYMBOL_START = /[_$a-zA-Z]/;\n        var SYMBOL_CONT = /[_$a-zA-Z0-9]/;\n        var STRINGISH_START = ['\"', \"'\", \"/\"];\n        var NOT_WHITESPACE = /[^\\s]/;\n        function tokenizeString(str) {\n            var tokens = [];\n            var position = 0;\n            while (position < str.length) {\n                if(SYMBOL_START.exec(str.charAt(position))) {\n                    var startPosition = position;\n                    while (SYMBOL_CONT.exec(str.charAt(position + 1))) {\n                        position++;\n                    }\n                    tokens.push(str.substr(startPosition, position - startPosition + 1));\n                } else if (STRINGISH_START.indexOf(str.charAt(position)) !== -1) {\n                    var startChar = str.charAt(position);\n                    var startPosition = position;\n                    position++;\n                    while (position < str.length && str.charAt(position) !== startChar ) {\n                        if (str.charAt(position) === \"\\\\\") {\n                            position++;\n                        }\n                        position++;\n                    }\n                    tokens.push(str.substr(startPosition, position - startPosition + 1));\n                } else {\n                    var symbol = str.charAt(position);\n                    tokens.push(symbol);\n                }\n                position++;\n            }\n            return tokens;\n        }\n\n        function isPossibleRelativeReference(token, last, paramName) {\n            return SYMBOL_START.exec(token.charAt(0)) &&\n                token !== \"true\" &&\n                token !== \"false\" &&\n                token !== \"this\" &&\n                token !== paramName &&\n                last !== \".\";\n        }\n\n        function maybeGenerateConditional(elt, tokens, paramName) {\n            if (tokens[0] === '[') {\n                tokens.shift();\n                var bracketCount = 1;\n                var conditionalSource = \" return (function(\" + paramName + \"){ return (\";\n                var last = null;\n                while (tokens.length > 0) {\n                    var token = tokens[0];\n                    if (token === \"]\") {\n                        bracketCount--;\n                        if (bracketCount === 0) {\n                            if (last === null) {\n                                conditionalSource = conditionalSource + \"true\";\n                            }\n                            tokens.shift();\n                            conditionalSource += \")})\";\n                            try {\n                                var conditionFunction = maybeEval(elt,function () {\n                                    return Function(conditionalSource)();\n                                    },\n                                    function(){return true})\n                                conditionFunction.source = conditionalSource;\n                                return conditionFunction;\n                            } catch (e) {\n                                triggerErrorEvent(getDocument().body, \"htmx:syntax:error\", {error:e, source:conditionalSource})\n                                return null;\n                            }\n                        }\n                    } else if (token === \"[\") {\n                        bracketCount++;\n                    }\n                    if (isPossibleRelativeReference(token, last, paramName)) {\n                            conditionalSource += \"((\" + paramName + \".\" + token + \") ? (\" + paramName + \".\" + token + \") : (window.\" + token + \"))\";\n                    } else {\n                        conditionalSource = conditionalSource + token;\n                    }\n                    last = tokens.shift();\n                }\n            }\n        }\n\n        function consumeUntil(tokens, match) {\n            var result = \"\";\n            while (tokens.length > 0 && !tokens[0].match(match)) {\n                result += tokens.shift();\n            }\n            return result;\n        }\n\n        var INPUT_SELECTOR = 'input, textarea, select';\n\n        /**\n         * @param {HTMLElement} elt\n         * @returns {import(\"./htmx\").HtmxTriggerSpecification[]}\n         */\n        function getTriggerSpecs(elt) {\n            var explicitTrigger = getAttributeValue(elt, 'hx-trigger');\n            var triggerSpecs = [];\n            if (explicitTrigger) {\n                var tokens = tokenizeString(explicitTrigger);\n                do {\n                    consumeUntil(tokens, NOT_WHITESPACE);\n                    var initialLength = tokens.length;\n                    var trigger = consumeUntil(tokens, /[,\\[\\s]/);\n                    if (trigger !== \"\") {\n                        if (trigger === \"every\") {\n                            var every = {trigger: 'every'};\n                            consumeUntil(tokens, NOT_WHITESPACE);\n                            every.pollInterval = parseInterval(consumeUntil(tokens, /[,\\[\\s]/));\n                            consumeUntil(tokens, NOT_WHITESPACE);\n                            var eventFilter = maybeGenerateConditional(elt, tokens, \"event\");\n                            if (eventFilter) {\n                                every.eventFilter = eventFilter;\n                            }\n                            triggerSpecs.push(every);\n                        } else if (trigger.indexOf(\"sse:\") === 0) {\n                            triggerSpecs.push({trigger: 'sse', sseEvent: trigger.substr(4)});\n                        } else {\n                            var triggerSpec = {trigger: trigger};\n                            var eventFilter = maybeGenerateConditional(elt, tokens, \"event\");\n                            if (eventFilter) {\n                                triggerSpec.eventFilter = eventFilter;\n                            }\n                            while (tokens.length > 0 && tokens[0] !== \",\") {\n                                consumeUntil(tokens, NOT_WHITESPACE)\n                                var token = tokens.shift();\n                                if (token === \"changed\") {\n                                    triggerSpec.changed = true;\n                                } else if (token === \"once\") {\n                                    triggerSpec.once = true;\n                                } else if (token === \"consume\") {\n                                    triggerSpec.consume = true;\n                                } else if (token === \"delay\" && tokens[0] === \":\") {\n                                    tokens.shift();\n                                    triggerSpec.delay = parseInterval(consumeUntil(tokens, WHITESPACE_OR_COMMA));\n                                } else if (token === \"from\" && tokens[0] === \":\") {\n                                    tokens.shift();\n                                    var from_arg = consumeUntil(tokens, WHITESPACE_OR_COMMA);\n                                    if (from_arg === \"closest\" || from_arg === \"find\" || from_arg === \"next\" || from_arg === \"previous\") {\n                                        tokens.shift();\n                                        from_arg +=\n                                            \" \" +\n                                            consumeUntil(\n                                                tokens,\n                                                WHITESPACE_OR_COMMA\n                                            );\n                                    }\n                                    triggerSpec.from = from_arg;\n                                } else if (token === \"target\" && tokens[0] === \":\") {\n                                    tokens.shift();\n                                    triggerSpec.target = consumeUntil(tokens, WHITESPACE_OR_COMMA);\n                                } else if (token === \"throttle\" && tokens[0] === \":\") {\n                                    tokens.shift();\n                                    triggerSpec.throttle = parseInterval(consumeUntil(tokens, WHITESPACE_OR_COMMA));\n                                } else if (token === \"queue\" && tokens[0] === \":\") {\n                                    tokens.shift();\n                                    triggerSpec.queue = consumeUntil(tokens, WHITESPACE_OR_COMMA);\n                                } else if ((token === \"root\" || token === \"threshold\") && tokens[0] === \":\") {\n                                    tokens.shift();\n                                    triggerSpec[token] = consumeUntil(tokens, WHITESPACE_OR_COMMA);\n                                } else {\n                                    triggerErrorEvent(elt, \"htmx:syntax:error\", {token:tokens.shift()});\n                                }\n                            }\n                            triggerSpecs.push(triggerSpec);\n                        }\n                    }\n                    if (tokens.length === initialLength) {\n                        triggerErrorEvent(elt, \"htmx:syntax:error\", {token:tokens.shift()});\n                    }\n                    consumeUntil(tokens, NOT_WHITESPACE);\n                } while (tokens[0] === \",\" && tokens.shift())\n            }\n\n            if (triggerSpecs.length > 0) {\n                return triggerSpecs;\n            } else if (matches(elt, 'form')) {\n                return [{trigger: 'submit'}];\n            } else if (matches(elt, 'input[type=\"button\"]')){\n                return [{trigger: 'click'}];\n            } else if (matches(elt, INPUT_SELECTOR)) {\n                return [{trigger: 'change'}];\n            } else {\n                return [{trigger: 'click'}];\n            }\n        }\n\n        function cancelPolling(elt) {\n            getInternalData(elt).cancelled = true;\n        }\n\n        function processPolling(elt, handler, spec) {\n            var nodeData = getInternalData(elt);\n            nodeData.timeout = setTimeout(function () {\n                if (bodyContains(elt) && nodeData.cancelled !== true) {\n                    if (!maybeFilterEvent(spec, makeEvent('hx:poll:trigger', {triggerSpec:spec, target:elt}))) {\n                        handler(elt);\n                    }\n                    processPolling(elt, handler, spec);\n                }\n            }, spec.pollInterval);\n        }\n\n        function isLocalLink(elt) {\n            return location.hostname === elt.hostname &&\n                getRawAttribute(elt,'href') &&\n                getRawAttribute(elt,'href').indexOf(\"#\") !== 0;\n        }\n\n        function boostElement(elt, nodeData, triggerSpecs) {\n            if ((elt.tagName === \"A\" && isLocalLink(elt) && (elt.target === \"\" || elt.target === \"_self\")) || elt.tagName === \"FORM\") {\n                nodeData.boosted = true;\n                var verb, path;\n                if (elt.tagName === \"A\") {\n                    verb = \"get\";\n                    path = getRawAttribute(elt, 'href');\n                } else {\n                    var rawAttribute = getRawAttribute(elt, \"method\");\n                    verb = rawAttribute ? rawAttribute.toLowerCase() : \"get\";\n                    if (verb === \"get\") {\n                    }\n                    path = getRawAttribute(elt, 'action');\n                }\n                triggerSpecs.forEach(function(triggerSpec) {\n                    addEventListener(elt, function(elt, evt) {\n                        issueAjaxRequest(verb, path, elt, evt)\n                    }, nodeData, triggerSpec, true);\n                });\n            }\n        }\n\n        /**\n         *\n         * @param {Event} evt\n         * @param {HTMLElement} elt\n         * @returns\n         */\n        function shouldCancel(evt, elt) {\n            if (evt.type === \"submit\" || evt.type === \"click\") {\n                if (elt.tagName === \"FORM\") {\n                    return true;\n                }\n                if (matches(elt, 'input[type=\"submit\"], button') && closest(elt, 'form') !== null) {\n                    return true;\n                }\n                if (elt.tagName === \"A\" && elt.href &&\n                    (elt.getAttribute('href') === '#' || elt.getAttribute('href').indexOf(\"#\") !== 0)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        function ignoreBoostedAnchorCtrlClick(elt, evt) {\n            return getInternalData(elt).boosted && elt.tagName === \"A\" && evt.type === \"click\" && (evt.ctrlKey || evt.metaKey);\n        }\n\n        function maybeFilterEvent(triggerSpec, evt) {\n            var eventFilter = triggerSpec.eventFilter;\n            if(eventFilter){\n                try {\n                    return eventFilter(evt) !== true;\n                } catch(e) {\n                    triggerErrorEvent(getDocument().body, \"htmx:eventFilter:error\", {error: e, source:eventFilter.source});\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        function addEventListener(elt, handler, nodeData, triggerSpec, explicitCancel) {\n            var elementData = getInternalData(elt);\n            var eltsToListenOn;\n            if (triggerSpec.from) {\n                eltsToListenOn = querySelectorAllExt(elt, triggerSpec.from);\n            } else {\n                eltsToListenOn = [elt];\n            }\n            // store the initial value of the element so we can tell if it changes\n            if (triggerSpec.changed) {\n                elementData.lastValue = elt.value;\n            }\n            forEach(eltsToListenOn, function (eltToListenOn) {\n                var eventListener = function (evt) {\n                    if (!bodyContains(elt)) {\n                        eltToListenOn.removeEventListener(triggerSpec.trigger, eventListener);\n                        return;\n                    }\n                    if (ignoreBoostedAnchorCtrlClick(elt, evt)) {\n                        return;\n                    }\n                    if (explicitCancel || shouldCancel(evt, elt)) {\n                        evt.preventDefault();\n                    }\n                    if (maybeFilterEvent(triggerSpec, evt)) {\n                        return;\n                    }\n                    var eventData = getInternalData(evt);\n                    eventData.triggerSpec = triggerSpec;\n                    if (eventData.handledFor == null) {\n                        eventData.handledFor = [];\n                    }\n                    if (eventData.handledFor.indexOf(elt) < 0) {\n                        eventData.handledFor.push(elt);\n                        if (triggerSpec.consume) {\n                            evt.stopPropagation();\n                        }\n                        if (triggerSpec.target && evt.target) {\n                            if (!matches(evt.target, triggerSpec.target)) {\n                                return;\n                            }\n                        }\n                        if (triggerSpec.once) {\n                            if (elementData.triggeredOnce) {\n                                return;\n                            } else {\n                                elementData.triggeredOnce = true;\n                            }\n                        }\n                        if (triggerSpec.changed) {\n                            if (elementData.lastValue === elt.value) {\n                                return;\n                            } else {\n                                elementData.lastValue = elt.value;\n                            }\n                        }\n                        if (elementData.delayed) {\n                            clearTimeout(elementData.delayed);\n                        }\n                        if (elementData.throttle) {\n                            return;\n                        }\n\n                        if (triggerSpec.throttle) {\n                            if (!elementData.throttle) {\n                                handler(elt, evt);\n                                elementData.throttle = setTimeout(function () {\n                                    elementData.throttle = null;\n                                }, triggerSpec.throttle);\n                            }\n                        } else if (triggerSpec.delay) {\n                            elementData.delayed = setTimeout(function() { handler(elt, evt) }, triggerSpec.delay);\n                        } else {\n                            handler(elt, evt);\n                        }\n                    }\n                };\n                if (nodeData.listenerInfos == null) {\n                    nodeData.listenerInfos = [];\n                }\n                nodeData.listenerInfos.push({\n                    trigger: triggerSpec.trigger,\n                    listener: eventListener,\n                    on: eltToListenOn\n                })\n                eltToListenOn.addEventListener(triggerSpec.trigger, eventListener);\n            });\n        }\n\n        var windowIsScrolling = false // used by initScrollHandler\n        var scrollHandler = null;\n        function initScrollHandler() {\n            if (!scrollHandler) {\n                scrollHandler = function() {\n                    windowIsScrolling = true\n                };\n                window.addEventListener(\"scroll\", scrollHandler)\n                setInterval(function() {\n                    if (windowIsScrolling) {\n                        windowIsScrolling = false;\n                        forEach(getDocument().querySelectorAll(\"[hx-trigger='revealed'],[data-hx-trigger='revealed']\"), function (elt) {\n                            maybeReveal(elt);\n                        })\n                    }\n                }, 200);\n            }\n        }\n\n        function maybeReveal(elt) {\n            if (!hasAttribute(elt,'data-hx-revealed') && isScrolledIntoView(elt)) {\n                elt.setAttribute('data-hx-revealed', 'true');\n                var nodeData = getInternalData(elt);\n                if (nodeData.initHash) {\n                    triggerEvent(elt, 'revealed');\n                } else {\n                    // if the node isn't initialized, wait for it before triggering the request\n                    elt.addEventListener(\"htmx:afterProcessNode\", function(evt) { triggerEvent(elt, 'revealed') }, {once: true});\n                }\n            }\n        }\n\n        //====================================================================\n        // Web Sockets\n        //====================================================================\n\n        function processWebSocketInfo(elt, nodeData, info) {\n            var values = splitOnWhitespace(info);\n            for (var i = 0; i < values.length; i++) {\n                var value = values[i].split(/:(.+)/);\n                if (value[0] === \"connect\") {\n                    ensureWebSocket(elt, value[1], 0);\n                }\n                if (value[0] === \"send\") {\n                    processWebSocketSend(elt);\n                }\n            }\n        }\n\n        function ensureWebSocket(elt, wssSource, retryCount) {\n            if (!bodyContains(elt)) {\n                return;  // stop ensuring websocket connection when socket bearing element ceases to exist\n            }\n\n            if (wssSource.indexOf(\"/\") == 0) {  // complete absolute paths only\n                var base_part = location.hostname + (location.port ? ':'+location.port: '');\n                if (location.protocol == 'https:') {\n                    wssSource = \"wss://\" + base_part + wssSource;\n                } else if (location.protocol == 'http:') {\n                    wssSource = \"ws://\" + base_part + wssSource;\n                }\n            }\n            var socket = htmx.createWebSocket(wssSource);\n            socket.onerror = function (e) {\n                triggerErrorEvent(elt, \"htmx:wsError\", {error:e, socket:socket});\n                maybeCloseWebSocketSource(elt);\n            };\n\n            socket.onclose = function (e) {\n                if ([1006, 1012, 1013].indexOf(e.code) >= 0) {  // Abnormal Closure/Service Restart/Try Again Later\n                    var delay = getWebSocketReconnectDelay(retryCount);\n                    setTimeout(function() {\n                        ensureWebSocket(elt, wssSource, retryCount+1);  // creates a websocket with a new timeout\n                    }, delay);\n                }\n            };\n            socket.onopen = function (e) {\n                retryCount = 0;\n            }\n\n            getInternalData(elt).webSocket = socket;\n            socket.addEventListener('message', function (event) {\n                if (maybeCloseWebSocketSource(elt)) {\n                    return;\n                }\n\n                var response = event.data;\n                withExtensions(elt, function(extension){\n                    response = extension.transformResponse(response, null, elt);\n                });\n\n                var settleInfo = makeSettleInfo(elt);\n                var fragment = makeFragment(response);\n                var children = toArray(fragment.children);\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n                    oobSwap(getAttributeValue(child, \"hx-swap-oob\") || \"true\", child, settleInfo);\n                }\n\n                settleImmediately(settleInfo.tasks);\n            });\n        }\n\n        function maybeCloseWebSocketSource(elt) {\n            if (!bodyContains(elt)) {\n                getInternalData(elt).webSocket.close();\n                return true;\n            }\n        }\n\n        function processWebSocketSend(elt) {\n            var webSocketSourceElt = getClosestMatch(elt, function (parent) {\n                return getInternalData(parent).webSocket != null;\n            });\n            if (webSocketSourceElt) {\n                elt.addEventListener(getTriggerSpecs(elt)[0].trigger, function (evt) {\n                    var webSocket = getInternalData(webSocketSourceElt).webSocket;\n                    var headers = getHeaders(elt, webSocketSourceElt);\n                    var results = getInputValues(elt, 'post');\n                    var errors = results.errors;\n                    var rawParameters = results.values;\n                    var expressionVars = getExpressionVars(elt);\n                    var allParameters = mergeObjects(rawParameters, expressionVars);\n                    var filteredParameters = filterValues(allParameters, elt);\n                    filteredParameters['HEADERS'] = headers;\n                    if (errors && errors.length > 0) {\n                        triggerEvent(elt, 'htmx:validation:halted', errors);\n                        return;\n                    }\n                    webSocket.send(JSON.stringify(filteredParameters));\n                    if(shouldCancel(evt, elt)){\n                        evt.preventDefault();\n                    }\n                });\n            } else {\n                triggerErrorEvent(elt, \"htmx:noWebSocketSourceError\");\n            }\n        }\n\n        function getWebSocketReconnectDelay(retryCount) {\n            var delay = htmx.config.wsReconnectDelay;\n            if (typeof delay === 'function') {\n                // @ts-ignore\n                return delay(retryCount);\n            }\n            if (delay === 'full-jitter') {\n                var exp = Math.min(retryCount, 6);\n                var maxDelay = 1000 * Math.pow(2, exp);\n                return maxDelay * Math.random();\n            }\n            logError('htmx.config.wsReconnectDelay must either be a function or the string \"full-jitter\"');\n        }\n\n        //====================================================================\n        // Server Sent Events\n        //====================================================================\n\n        function processSSEInfo(elt, nodeData, info) {\n            var values = splitOnWhitespace(info);\n            for (var i = 0; i < values.length; i++) {\n                var value = values[i].split(/:(.+)/);\n                if (value[0] === \"connect\") {\n                    processSSESource(elt, value[1]);\n                }\n\n                if ((value[0] === \"swap\")) {\n                    processSSESwap(elt, value[1])\n                }\n            }\n        }\n\n        function processSSESource(elt, sseSrc) {\n            var source = htmx.createEventSource(sseSrc);\n            source.onerror = function (e) {\n                triggerErrorEvent(elt, \"htmx:sseError\", {error:e, source:source});\n                maybeCloseSSESource(elt);\n            };\n            getInternalData(elt).sseEventSource = source;\n        }\n\n        function processSSESwap(elt, sseEventName) {\n            var sseSourceElt = getClosestMatch(elt, hasEventSource);\n            if (sseSourceElt) {\n                var sseEventSource = getInternalData(sseSourceElt).sseEventSource;\n                var sseListener = function (event) {\n                    if (maybeCloseSSESource(sseSourceElt)) {\n                        sseEventSource.removeEventListener(sseEventName, sseListener);\n                        return;\n                    }\n\n                    ///////////////////////////\n                    // TODO: merge this code with AJAX and WebSockets code in the future.\n\n                    var response = event.data;\n                    withExtensions(elt, function(extension){\n                        response = extension.transformResponse(response, null, elt);\n                    });\n\n                    var swapSpec = getSwapSpecification(elt)\n                    var target = getTarget(elt)\n                    var settleInfo = makeSettleInfo(elt);\n\n                    selectAndSwap(swapSpec.swapStyle, elt, target, response, settleInfo)\n                    settleImmediately(settleInfo.tasks)\n                    triggerEvent(elt, \"htmx:sseMessage\", event)\n                };\n\n                getInternalData(elt).sseListener = sseListener;\n                sseEventSource.addEventListener(sseEventName, sseListener);\n            } else {\n                triggerErrorEvent(elt, \"htmx:noSSESourceError\");\n            }\n        }\n\n        function processSSETrigger(elt, handler, sseEventName) {\n            var sseSourceElt = getClosestMatch(elt, hasEventSource);\n            if (sseSourceElt) {\n                var sseEventSource = getInternalData(sseSourceElt).sseEventSource;\n                var sseListener = function () {\n                    if (!maybeCloseSSESource(sseSourceElt)) {\n                        if (bodyContains(elt)) {\n                            handler(elt);\n                        } else {\n                            sseEventSource.removeEventListener(sseEventName, sseListener);\n                        }\n                    }\n                };\n                getInternalData(elt).sseListener = sseListener;\n                sseEventSource.addEventListener(sseEventName, sseListener);\n            } else {\n                triggerErrorEvent(elt, \"htmx:noSSESourceError\");\n            }\n        }\n\n        function maybeCloseSSESource(elt) {\n            if (!bodyContains(elt)) {\n                getInternalData(elt).sseEventSource.close();\n                return true;\n            }\n        }\n\n        function hasEventSource(node) {\n            return getInternalData(node).sseEventSource != null;\n        }\n\n        //====================================================================\n\n        function loadImmediately(elt, handler, nodeData, delay) {\n            var load = function(){\n                if (!nodeData.loaded) {\n                    nodeData.loaded = true;\n                    handler(elt);\n                }\n            }\n            if (delay) {\n                setTimeout(load, delay);\n            } else {\n                load();\n            }\n        }\n\n        function processVerbs(elt, nodeData, triggerSpecs) {\n            var explicitAction = false;\n            forEach(VERBS, function (verb) {\n                if (hasAttribute(elt,'hx-' + verb)) {\n                    var path = getAttributeValue(elt, 'hx-' + verb);\n                    explicitAction = true;\n                    nodeData.path = path;\n                    nodeData.verb = verb;\n                    triggerSpecs.forEach(function(triggerSpec) {\n                        addTriggerHandler(elt, triggerSpec, nodeData, function (elt, evt) {\n                            issueAjaxRequest(verb, path, elt, evt)\n                        })\n                    });\n                }\n            });\n            return explicitAction;\n        }\n\n        function addTriggerHandler(elt, triggerSpec, nodeData, handler) {\n            if (triggerSpec.sseEvent) {\n                processSSETrigger(elt, handler, triggerSpec.sseEvent);\n            } else if (triggerSpec.trigger === \"revealed\") {\n                initScrollHandler();\n                addEventListener(elt, handler, nodeData, triggerSpec);\n                maybeReveal(elt);\n            } else if (triggerSpec.trigger === \"intersect\") {\n                var observerOptions = {};\n                if (triggerSpec.root) {\n                    observerOptions.root = querySelectorExt(elt, triggerSpec.root)\n                }\n                if (triggerSpec.threshold) {\n                    observerOptions.threshold = parseFloat(triggerSpec.threshold);\n                }\n                var observer = new IntersectionObserver(function (entries) {\n                    for (var i = 0; i < entries.length; i++) {\n                        var entry = entries[i];\n                        if (entry.isIntersecting) {\n                            triggerEvent(elt, \"intersect\");\n                            break;\n                        }\n                    }\n                }, observerOptions);\n                observer.observe(elt);\n                addEventListener(elt, handler, nodeData, triggerSpec);\n            } else if (triggerSpec.trigger === \"load\") {\n                if (!maybeFilterEvent(triggerSpec, makeEvent(\"load\", {elt:elt}))) {\n                                loadImmediately(elt, handler, nodeData, triggerSpec.delay);\n                            }\n            } else if (triggerSpec.pollInterval) {\n                nodeData.polling = true;\n                processPolling(elt, handler, triggerSpec);\n            } else {\n                addEventListener(elt, handler, nodeData, triggerSpec);\n            }\n        }\n\n        function evalScript(script) {\n            if (script.type === \"text/javascript\" || script.type === \"module\" || script.type === \"\") {\n                var newScript = getDocument().createElement(\"script\");\n                forEach(script.attributes, function (attr) {\n                    newScript.setAttribute(attr.name, attr.value);\n                });\n                newScript.textContent = script.textContent;\n                newScript.async = false;\n                if (htmx.config.inlineScriptNonce) {\n                    newScript.nonce = htmx.config.inlineScriptNonce;\n                }\n                var parent = script.parentElement;\n\n                try {\n                    parent.insertBefore(newScript, script);\n                } catch (e) {\n                    logError(e);\n                } finally {\n                    // remove old script element, but only if it is still in DOM\n                    if (script.parentElement) {\n                        script.parentElement.removeChild(script);\n                    }\n                }\n            }\n        }\n\n        function processScripts(elt) {\n            if (matches(elt, \"script\")) {\n                evalScript(elt);\n            }\n            forEach(findAll(elt, \"script\"), function (script) {\n                evalScript(script);\n            });\n        }\n\n        function hasChanceOfBeingBoosted() {\n            return document.querySelector(\"[hx-boost], [data-hx-boost]\");\n        }\n\n        function findElementsToProcess(elt) {\n            if (elt.querySelectorAll) {\n                var boostedElts = hasChanceOfBeingBoosted() ? \", a, form\" : \"\";\n                var results = elt.querySelectorAll(VERB_SELECTOR + boostedElts + \", [hx-sse], [data-hx-sse], [hx-ws],\" +\n                    \" [data-hx-ws], [hx-ext], [data-hx-ext]\");\n                return results;\n            } else {\n                return [];\n            }\n        }\n\n        function initButtonTracking(form){\n            var maybeSetLastButtonClicked = function(evt){\n                var elt = closest(evt.target, \"button, input[type='submit']\");\n                if (elt !== null) {\n                    var internalData = getInternalData(form);\n                    internalData.lastButtonClicked = elt;\n                }\n            };\n\n            // need to handle both click and focus in:\n            //   focusin - in case someone tabs in to a button and hits the space bar\n            //   click - on OSX buttons do not focus on click see https://bugs.webkit.org/show_bug.cgi?id=13724\n\n            form.addEventListener('click', maybeSetLastButtonClicked)\n            form.addEventListener('focusin', maybeSetLastButtonClicked)\n            form.addEventListener('focusout', function(evt){\n                var internalData = getInternalData(form);\n                internalData.lastButtonClicked = null;\n            })\n        }\n\n        function initNode(elt) {\n            if (elt.closest && elt.closest(htmx.config.disableSelector)) {\n                return;\n            }\n            var nodeData = getInternalData(elt);\n            if (nodeData.initHash !== attributeHash(elt)) {\n\n                nodeData.initHash = attributeHash(elt);\n\n                // clean up any previously processed info\n                deInitNode(elt);\n\n                triggerEvent(elt, \"htmx:beforeProcessNode\")\n\n                if (elt.value) {\n                    nodeData.lastValue = elt.value;\n                }\n\n                var triggerSpecs = getTriggerSpecs(elt);\n                var explicitAction = processVerbs(elt, nodeData, triggerSpecs);\n\n                if (!explicitAction && getClosestAttributeValue(elt, \"hx-boost\") === \"true\") {\n                    boostElement(elt, nodeData, triggerSpecs);\n                }\n\n                if (elt.tagName === \"FORM\") {\n                    initButtonTracking(elt);\n                }\n\n                var sseInfo = getAttributeValue(elt, 'hx-sse');\n                if (sseInfo) {\n                    processSSEInfo(elt, nodeData, sseInfo);\n                }\n\n                var wsInfo = getAttributeValue(elt, 'hx-ws');\n                if (wsInfo) {\n                    processWebSocketInfo(elt, nodeData, wsInfo);\n                }\n                triggerEvent(elt, \"htmx:afterProcessNode\");\n            }\n        }\n\n        function processNode(elt) {\n            elt = resolveTarget(elt);\n            initNode(elt);\n            forEach(findElementsToProcess(elt), function(child) { initNode(child) });\n        }\n\n        //====================================================================\n        // Event/Log Support\n        //====================================================================\n\n        function kebabEventName(str) {\n            return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();\n        }\n\n        function makeEvent(eventName, detail) {\n            var evt;\n            if (window.CustomEvent && typeof window.CustomEvent === 'function') {\n                evt = new CustomEvent(eventName, {bubbles: true, cancelable: true, detail: detail});\n            } else {\n                evt = getDocument().createEvent('CustomEvent');\n                evt.initCustomEvent(eventName, true, true, detail);\n            }\n            return evt;\n        }\n\n        function triggerErrorEvent(elt, eventName, detail) {\n            triggerEvent(elt, eventName, mergeObjects({error:eventName}, detail));\n        }\n\n        function ignoreEventForLogging(eventName) {\n            return eventName === \"htmx:afterProcessNode\"\n        }\n\n        /**\n         * `withExtensions` locates all active extensions for a provided element, then\n         * executes the provided function using each of the active extensions.  It should\n         * be called internally at every extendable execution point in htmx.\n         *\n         * @param {HTMLElement} elt\n         * @param {(extension:import(\"./htmx\").HtmxExtension) => void} toDo\n         * @returns void\n         */\n        function withExtensions(elt, toDo) {\n            forEach(getExtensions(elt), function(extension){\n                try {\n                    toDo(extension);\n                } catch (e) {\n                    logError(e);\n                }\n            });\n        }\n\n        function logError(msg) {\n            if(console.error) {\n                console.error(msg);\n            } else if (console.log) {\n                console.log(\"ERROR: \", msg);\n            }\n        }\n\n        function triggerEvent(elt, eventName, detail) {\n            elt = resolveTarget(elt);\n            if (detail == null) {\n                detail = {};\n            }\n            detail[\"elt\"] = elt;\n            var event = makeEvent(eventName, detail);\n            if (htmx.logger && !ignoreEventForLogging(eventName)) {\n                htmx.logger(elt, eventName, detail);\n            }\n            if (detail.error) {\n                logError(detail.error);\n                triggerEvent(elt, \"htmx:error\", {errorInfo:detail})\n            }\n            var eventResult = elt.dispatchEvent(event);\n            var kebabName = kebabEventName(eventName);\n            if (eventResult && kebabName !== eventName) {\n                var kebabedEvent = makeEvent(kebabName, event.detail);\n                eventResult = eventResult && elt.dispatchEvent(kebabedEvent)\n            }\n            withExtensions(elt, function (extension) {\n                eventResult = eventResult && (extension.onEvent(eventName, event) !== false)\n            });\n            return eventResult;\n        }\n\n        //====================================================================\n        // History Support\n        //====================================================================\n        var currentPathForHistory = location.pathname+location.search;\n\n        function getHistoryElement() {\n            var historyElt = getDocument().querySelector('[hx-history-elt],[data-hx-history-elt]');\n            return historyElt || getDocument().body;\n        }\n\n        function saveToHistoryCache(url, content, title, scroll) {\n            if (!canAccessLocalStorage()) {\n                return;\n            }\n\n            var historyCache = parseJSON(localStorage.getItem(\"htmx-history-cache\")) || [];\n            for (var i = 0; i < historyCache.length; i++) {\n                if (historyCache[i].url === url) {\n                    historyCache.splice(i, 1);\n                    break;\n                }\n            }\n            var newHistoryItem = {url:url, content: content, title:title, scroll:scroll};\n            triggerEvent(getDocument().body, \"htmx:historyItemCreated\", {item:newHistoryItem, cache: historyCache})\n            historyCache.push(newHistoryItem)\n            while (historyCache.length > htmx.config.historyCacheSize) {\n                historyCache.shift();\n            }\n            while(historyCache.length > 0){\n                try {\n                    localStorage.setItem(\"htmx-history-cache\", JSON.stringify(historyCache));\n                    break;\n                } catch (e) {\n                    triggerErrorEvent(getDocument().body, \"htmx:historyCacheError\", {cause:e, cache: historyCache})\n                    historyCache.shift(); // shrink the cache and retry\n                }\n            }\n        }\n\n        function getCachedHistory(url) {\n            if (!canAccessLocalStorage()) {\n                return null;\n            }\n\n            var historyCache = parseJSON(localStorage.getItem(\"htmx-history-cache\")) || [];\n            for (var i = 0; i < historyCache.length; i++) {\n                if (historyCache[i].url === url) {\n                    return historyCache[i];\n                }\n            }\n            return null;\n        }\n\n        function cleanInnerHtmlForHistory(elt) {\n            var className = htmx.config.requestClass;\n            var clone = elt.cloneNode(true);\n            forEach(findAll(clone, \".\" + className), function(child){\n                removeClassFromElement(child, className);\n            });\n            return clone.innerHTML;\n        }\n\n        function saveCurrentPageToHistory() {\n            var elt = getHistoryElement();\n            var path = currentPathForHistory || location.pathname+location.search;\n\n            // Allow history snapshot feature to be disabled where hx-history=\"false\"\n            // is present *anywhere* in the current document we're about to save,\n            // so we can prevent privileged data entering the cache.\n            // The page will still be reachable as a history entry, but htmx will fetch it\n            // live from the server onpopstate rather than look in the localStorage cache\n            var disableHistoryCache = getDocument().querySelector('[hx-history=\"false\" i],[data-hx-history=\"false\" i]');\n            if (!disableHistoryCache) {\n                triggerEvent(getDocument().body, \"htmx:beforeHistorySave\", {path: path, historyElt: elt});\n                saveToHistoryCache(path, cleanInnerHtmlForHistory(elt), getDocument().title, window.scrollY);\n            }\n\n            if (htmx.config.historyEnabled) history.replaceState({htmx: true}, getDocument().title, window.location.href);\n        }\n\n        function pushUrlIntoHistory(path) {\n            // remove the cache buster parameter, if any\n            if (htmx.config.getCacheBusterParam) {\n                path = path.replace(/org\\.htmx\\.cache-buster=[^&]*&?/, '')\n                if (path.endsWith('&') || path.endsWith(\"?\")) {\n                    path = path.slice(0, -1);\n                }\n            }\n            if(htmx.config.historyEnabled) {\n                history.pushState({htmx:true}, \"\", path);\n            }\n            currentPathForHistory = path;\n        }\n\n        function replaceUrlInHistory(path) {\n            if(htmx.config.historyEnabled)  history.replaceState({htmx:true}, \"\", path);\n            currentPathForHistory = path;\n        }\n\n        function settleImmediately(tasks) {\n            forEach(tasks, function (task) {\n                task.call();\n            });\n        }\n\n        function loadHistoryFromServer(path) {\n            var request = new XMLHttpRequest();\n            var details = {path: path, xhr:request};\n            triggerEvent(getDocument().body, \"htmx:historyCacheMiss\", details);\n            request.open('GET', path, true);\n            request.setRequestHeader(\"HX-History-Restore-Request\", \"true\");\n            request.onload = function () {\n                if (this.status >= 200 && this.status < 400) {\n                    triggerEvent(getDocument().body, \"htmx:historyCacheMissLoad\", details);\n                    var fragment = makeFragment(this.response);\n                    // @ts-ignore\n                    fragment = fragment.querySelector('[hx-history-elt],[data-hx-history-elt]') || fragment;\n                    var historyElement = getHistoryElement();\n                    var settleInfo = makeSettleInfo(historyElement);\n                    var title = findTitle(this.response);\n                    if (title) {\n                        var titleElt = find(\"title\");\n                        if (titleElt) {\n                            titleElt.innerHTML = title;\n                        } else {\n                            window.document.title = title;\n                        }\n                    }\n                    // @ts-ignore\n                    swapInnerHTML(historyElement, fragment, settleInfo)\n                    settleImmediately(settleInfo.tasks);\n                    currentPathForHistory = path;\n                    triggerEvent(getDocument().body, \"htmx:historyRestore\", {path: path, cacheMiss:true, serverResponse:this.response});\n                } else {\n                    triggerErrorEvent(getDocument().body, \"htmx:historyCacheMissLoadError\", details);\n                }\n            };\n            request.send();\n        }\n\n        function restoreHistory(path) {\n            saveCurrentPageToHistory();\n            path = path || location.pathname+location.search;\n            var cached = getCachedHistory(path);\n            if (cached) {\n                var fragment = makeFragment(cached.content);\n                var historyElement = getHistoryElement();\n                var settleInfo = makeSettleInfo(historyElement);\n                swapInnerHTML(historyElement, fragment, settleInfo)\n                settleImmediately(settleInfo.tasks);\n                document.title = cached.title;\n                window.scrollTo(0, cached.scroll);\n                currentPathForHistory = path;\n                triggerEvent(getDocument().body, \"htmx:historyRestore\", {path:path, item:cached});\n            } else {\n                if (htmx.config.refreshOnHistoryMiss) {\n\n                    // @ts-ignore: optional parameter in reload() function throws error\n                    window.location.reload(true);\n                } else {\n                    loadHistoryFromServer(path);\n                }\n            }\n        }\n\n        function addRequestIndicatorClasses(elt) {\n            var indicators = findAttributeTargets(elt, 'hx-indicator');\n            if (indicators == null) {\n                indicators = [elt];\n            }\n            forEach(indicators, function (ic) {\n                var internalData = getInternalData(ic);\n                internalData.requestCount = (internalData.requestCount || 0) + 1;\n                ic.classList[\"add\"].call(ic.classList, htmx.config.requestClass);\n            });\n            return indicators;\n        }\n\n        function removeRequestIndicatorClasses(indicators) {\n            forEach(indicators, function (ic) {\n                var internalData = getInternalData(ic);\n                internalData.requestCount = (internalData.requestCount || 0) - 1;\n                if (internalData.requestCount === 0) {\n                    ic.classList[\"remove\"].call(ic.classList, htmx.config.requestClass);\n                }\n            });\n        }\n\n        //====================================================================\n        // Input Value Processing\n        //====================================================================\n\n        function haveSeenNode(processed, elt) {\n            for (var i = 0; i < processed.length; i++) {\n                var node = processed[i];\n                if (node.isSameNode(elt)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        function shouldInclude(elt) {\n            if(elt.name === \"\" || elt.name == null || elt.disabled) {\n                return false;\n            }\n            // ignore \"submitter\" types (see jQuery src/serialize.js)\n            if (elt.type === \"button\" || elt.type === \"submit\" || elt.tagName === \"image\" || elt.tagName === \"reset\" || elt.tagName === \"file\" ) {\n                return false;\n            }\n            if (elt.type === \"checkbox\" || elt.type === \"radio\" ) {\n                return elt.checked;\n            }\n            return true;\n        }\n\n        function processInputValue(processed, values, errors, elt, validate) {\n            if (elt == null || haveSeenNode(processed, elt)) {\n                return;\n            } else {\n                processed.push(elt);\n            }\n            if (shouldInclude(elt)) {\n                var name = getRawAttribute(elt,\"name\");\n                var value = elt.value;\n                if (elt.multiple) {\n                    value = toArray(elt.querySelectorAll(\"option:checked\")).map(function (e) { return e.value });\n                }\n                // include file inputs\n                if (elt.files) {\n                    value = toArray(elt.files);\n                }\n                // This is a little ugly because both the current value of the named value in the form\n                // and the new value could be arrays, so we have to handle all four cases :/\n                if (name != null && value != null) {\n                    var current = values[name];\n                    if (current !== undefined) {\n                        if (Array.isArray(current)) {\n                            if (Array.isArray(value)) {\n                                values[name] = current.concat(value);\n                            } else {\n                                current.push(value);\n                            }\n                        } else {\n                            if (Array.isArray(value)) {\n                                values[name] = [current].concat(value);\n                            } else {\n                                values[name] = [current, value];\n                            }\n                        }\n                    } else {\n                        values[name] = value;\n                    }\n                }\n                if (validate) {\n                    validateElement(elt, errors);\n                }\n            }\n            if (matches(elt, 'form')) {\n                var inputs = elt.elements;\n                forEach(inputs, function(input) {\n                    processInputValue(processed, values, errors, input, validate);\n                });\n            }\n        }\n\n        function validateElement(element, errors) {\n            if (element.willValidate) {\n                triggerEvent(element, \"htmx:validation:validate\")\n                if (!element.checkValidity()) {\n                    errors.push({elt: element, message:element.validationMessage, validity:element.validity});\n                    triggerEvent(element, \"htmx:validation:failed\", {message:element.validationMessage, validity:element.validity})\n                }\n            }\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {string} verb\n         */\n        function getInputValues(elt, verb) {\n            var processed = [];\n            var values = {};\n            var formValues = {};\n            var errors = [];\n            var internalData = getInternalData(elt);\n\n            // only validate when form is directly submitted and novalidate or formnovalidate are not set\n            // or if the element has an explicit hx-validate=\"true\" on it\n            var validate = (matches(elt, 'form') && elt.noValidate !== true) || getAttributeValue(elt, \"hx-validate\") === \"true\";\n            if (internalData.lastButtonClicked) {\n                validate = validate && internalData.lastButtonClicked.formNoValidate !== true;\n            }\n\n            // for a non-GET include the closest form\n            if (verb !== 'get') {\n                processInputValue(processed, formValues, errors, closest(elt, 'form'), validate);\n            }\n\n            // include the element itself\n            processInputValue(processed, values, errors, elt, validate);\n\n            // if a button or submit was clicked last, include its value\n            if (internalData.lastButtonClicked) {\n                var name = getRawAttribute(internalData.lastButtonClicked,\"name\");\n                if (name) {\n                    values[name] = internalData.lastButtonClicked.value;\n                }\n            }\n\n            // include any explicit includes\n            var includes = findAttributeTargets(elt, \"hx-include\");\n            forEach(includes, function(node) {\n                processInputValue(processed, values, errors, node, validate);\n                // if a non-form is included, include any input values within it\n                if (!matches(node, 'form')) {\n                    forEach(node.querySelectorAll(INPUT_SELECTOR), function (descendant) {\n                        processInputValue(processed, values, errors, descendant, validate);\n                    })\n                }\n            });\n\n            // form values take precedence, overriding the regular values\n            values = mergeObjects(values, formValues);\n\n            return {errors:errors, values:values};\n        }\n\n        function appendParam(returnStr, name, realValue) {\n            if (returnStr !== \"\") {\n                returnStr += \"&\";\n            }\n            if (String(realValue) === \"[object Object]\") {\n                realValue = JSON.stringify(realValue);\n            }\n            var s = encodeURIComponent(realValue);\n            returnStr += encodeURIComponent(name) + \"=\" + s;\n            return returnStr;\n        }\n\n        function urlEncode(values) {\n            var returnStr = \"\";\n            for (var name in values) {\n                if (values.hasOwnProperty(name)) {\n                    var value = values[name];\n                    if (Array.isArray(value)) {\n                        forEach(value, function(v) {\n                            returnStr = appendParam(returnStr, name, v);\n                        });\n                    } else {\n                        returnStr = appendParam(returnStr, name, value);\n                    }\n                }\n            }\n            return returnStr;\n        }\n\n        function makeFormData(values) {\n            var formData = new FormData();\n            for (var name in values) {\n                if (values.hasOwnProperty(name)) {\n                    var value = values[name];\n                    if (Array.isArray(value)) {\n                        forEach(value, function(v) {\n                            formData.append(name, v);\n                        });\n                    } else {\n                        formData.append(name, value);\n                    }\n                }\n            }\n            return formData;\n        }\n\n        //====================================================================\n        // Ajax\n        //====================================================================\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {HTMLElement} target\n         * @param {string} prompt\n         * @returns {Object} // TODO: Define/Improve HtmxHeaderSpecification\n         */\n        function getHeaders(elt, target, prompt) {\n            var headers = {\n                \"HX-Request\" : \"true\",\n                \"HX-Trigger\" : getRawAttribute(elt, \"id\"),\n                \"HX-Trigger-Name\" : getRawAttribute(elt, \"name\"),\n                \"HX-Target\" : getAttributeValue(target, \"id\"),\n                \"HX-Current-URL\" : getDocument().location.href,\n            }\n            getValuesForElement(elt, \"hx-headers\", false, headers)\n            if (prompt !== undefined) {\n                headers[\"HX-Prompt\"] = prompt;\n            }\n            if (getInternalData(elt).boosted) {\n                headers[\"HX-Boosted\"] = \"true\";\n            }\n            return headers;\n        }\n\n        /**\n         * filterValues takes an object containing form input values\n         * and returns a new object that only contains keys that are\n         * specified by the closest \"hx-params\" attribute\n         * @param {Object} inputValues\n         * @param {HTMLElement} elt\n         * @returns {Object}\n         */\n        function filterValues(inputValues, elt) {\n            var paramsValue = getClosestAttributeValue(elt, \"hx-params\");\n            if (paramsValue) {\n                if (paramsValue === \"none\") {\n                    return {};\n                } else if (paramsValue === \"*\") {\n                    return inputValues;\n                } else if(paramsValue.indexOf(\"not \") === 0) {\n                    forEach(paramsValue.substr(4).split(\",\"), function (name) {\n                        name = name.trim();\n                        delete inputValues[name];\n                    });\n                    return inputValues;\n                } else {\n                    var newValues = {}\n                    forEach(paramsValue.split(\",\"), function (name) {\n                        name = name.trim();\n                        newValues[name] = inputValues[name];\n                    });\n                    return newValues;\n                }\n            } else {\n                return inputValues;\n            }\n        }\n\n        function isAnchorLink(elt) {\n          return getRawAttribute(elt, 'href') && getRawAttribute(elt, 'href').indexOf(\"#\") >=0\n        }\n\n        /**\n         *\n         * @param {HTMLElement} elt\n         * @param {string} swapInfoOverride\n         * @returns {import(\"./htmx\").HtmxSwapSpecification}\n         */\n        function getSwapSpecification(elt, swapInfoOverride) {\n            var swapInfo = swapInfoOverride ? swapInfoOverride : getClosestAttributeValue(elt, \"hx-swap\");\n            var swapSpec = {\n                \"swapStyle\" : getInternalData(elt).boosted ? 'innerHTML' : htmx.config.defaultSwapStyle,\n                \"swapDelay\" : htmx.config.defaultSwapDelay,\n                \"settleDelay\" : htmx.config.defaultSettleDelay\n            }\n            if (getInternalData(elt).boosted && !isAnchorLink(elt)) {\n              swapSpec[\"show\"] = \"top\"\n            }\n            if (swapInfo) {\n                var split = splitOnWhitespace(swapInfo);\n                if (split.length > 0) {\n                    swapSpec[\"swapStyle\"] = split[0];\n                    for (var i = 1; i < split.length; i++) {\n                        var modifier = split[i];\n                        if (modifier.indexOf(\"swap:\") === 0) {\n                            swapSpec[\"swapDelay\"] = parseInterval(modifier.substr(5));\n                        }\n                        if (modifier.indexOf(\"settle:\") === 0) {\n                            swapSpec[\"settleDelay\"] = parseInterval(modifier.substr(7));\n                        }\n                        if (modifier.indexOf(\"scroll:\") === 0) {\n                            var scrollSpec = modifier.substr(7);\n                            var splitSpec = scrollSpec.split(\":\");\n                            var scrollVal = splitSpec.pop();\n                            var selectorVal = splitSpec.length > 0 ? splitSpec.join(\":\") : null;\n                            swapSpec[\"scroll\"] = scrollVal;\n                            swapSpec[\"scrollTarget\"] = selectorVal;\n                        }\n                        if (modifier.indexOf(\"show:\") === 0) {\n                            var showSpec = modifier.substr(5);\n                            var splitSpec = showSpec.split(\":\");\n                            var showVal = splitSpec.pop();\n                            var selectorVal = splitSpec.length > 0 ? splitSpec.join(\":\") : null;\n                            swapSpec[\"show\"] = showVal;\n                            swapSpec[\"showTarget\"] = selectorVal;\n                        }\n                        if (modifier.indexOf(\"focus-scroll:\") === 0) {\n                            var focusScrollVal = modifier.substr(\"focus-scroll:\".length);\n                            swapSpec[\"focusScroll\"] = focusScrollVal == \"true\";\n                        }\n                    }\n                }\n            }\n            return swapSpec;\n        }\n\n        function usesFormData(elt) {\n            return getClosestAttributeValue(elt, \"hx-encoding\") === \"multipart/form-data\" ||\n                (matches(elt, \"form\") && getRawAttribute(elt, 'enctype') === \"multipart/form-data\");\n        }\n\n        function encodeParamsForBody(xhr, elt, filteredParameters) {\n            var encodedParameters = null;\n            withExtensions(elt, function (extension) {\n                if (encodedParameters == null) {\n                    encodedParameters = extension.encodeParameters(xhr, filteredParameters, elt);\n                }\n            });\n            if (encodedParameters != null) {\n                return encodedParameters;\n            } else {\n                if (usesFormData(elt)) {\n                    return makeFormData(filteredParameters);\n                } else {\n                    return urlEncode(filteredParameters);\n                }\n            }\n        }\n\n        /**\n         *\n         * @param {Element} target\n         * @returns {import(\"./htmx\").HtmxSettleInfo}\n         */\n        function makeSettleInfo(target) {\n            return {tasks: [], elts: [target]};\n        }\n\n        function updateScrollState(content, swapSpec) {\n            var first = content[0];\n            var last = content[content.length - 1];\n            if (swapSpec.scroll) {\n                var target = null;\n                if (swapSpec.scrollTarget) {\n                    target = querySelectorExt(first, swapSpec.scrollTarget);\n                }\n                if (swapSpec.scroll === \"top\" && (first || target)) {\n                    target = target || first;\n                    target.scrollTop = 0;\n                }\n                if (swapSpec.scroll === \"bottom\" && (last || target)) {\n                    target = target || last;\n                    target.scrollTop = target.scrollHeight;\n                }\n            }\n            if (swapSpec.show) {\n                var target = null;\n                if (swapSpec.showTarget) {\n                    var targetStr = swapSpec.showTarget;\n                    if (swapSpec.showTarget === \"window\") {\n                        targetStr = \"body\";\n                    }\n                    target = querySelectorExt(first, targetStr);\n                }\n                if (swapSpec.show === \"top\" && (first || target)) {\n                    target = target || first;\n                    target.scrollIntoView({block:'start', behavior: htmx.config.scrollBehavior});\n                }\n                if (swapSpec.show === \"bottom\" && (last || target)) {\n                    target = target || last;\n                    target.scrollIntoView({block:'end', behavior: htmx.config.scrollBehavior});\n                }\n            }\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {string} attr\n         * @param {boolean=} evalAsDefault\n         * @param {Object=} values\n         * @returns {Object}\n         */\n        function getValuesForElement(elt, attr, evalAsDefault, values) {\n            if (values == null) {\n                values = {};\n            }\n            if (elt == null) {\n                return values;\n            }\n            var attributeValue = getAttributeValue(elt, attr);\n            if (attributeValue) {\n                var str = attributeValue.trim();\n                var evaluateValue = evalAsDefault;\n                if (str === \"unset\") {\n                    return null;\n                }\n                if (str.indexOf(\"javascript:\") === 0) {\n                    str = str.substr(11);\n                    evaluateValue = true;\n                } else if (str.indexOf(\"js:\") === 0) {\n                    str = str.substr(3);\n                    evaluateValue = true;\n                }\n                if (str.indexOf('{') !== 0) {\n                    str = \"{\" + str + \"}\";\n                }\n                var varsValues;\n                if (evaluateValue) {\n                    varsValues = maybeEval(elt,function () {return Function(\"return (\" + str + \")\")();}, {});\n                } else {\n                    varsValues = parseJSON(str);\n                }\n                for (var key in varsValues) {\n                    if (varsValues.hasOwnProperty(key)) {\n                        if (values[key] == null) {\n                            values[key] = varsValues[key];\n                        }\n                    }\n                }\n            }\n            return getValuesForElement(parentElt(elt), attr, evalAsDefault, values);\n        }\n\n        function maybeEval(elt, toEval, defaultVal) {\n            if (htmx.config.allowEval) {\n                return toEval();\n            } else {\n                triggerErrorEvent(elt, 'htmx:evalDisallowedError');\n                return defaultVal;\n            }\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {*} expressionVars\n         * @returns\n         */\n        function getHXVarsForElement(elt, expressionVars) {\n            return getValuesForElement(elt, \"hx-vars\", true, expressionVars);\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {*} expressionVars\n         * @returns\n         */\n        function getHXValsForElement(elt, expressionVars) {\n            return getValuesForElement(elt, \"hx-vals\", false, expressionVars);\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @returns {Object}\n         */\n        function getExpressionVars(elt) {\n            return mergeObjects(getHXVarsForElement(elt), getHXValsForElement(elt));\n        }\n\n        function safelySetHeaderValue(xhr, header, headerValue) {\n            if (headerValue !== null) {\n                try {\n                    xhr.setRequestHeader(header, headerValue);\n                } catch (e) {\n                    // On an exception, try to set the header URI encoded instead\n                    xhr.setRequestHeader(header, encodeURIComponent(headerValue));\n                    xhr.setRequestHeader(header + \"-URI-AutoEncoded\", \"true\");\n                }\n            }\n        }\n\n        function getPathFromResponse(xhr) {\n            // NB: IE11 does not support this stuff\n            if (xhr.responseURL && typeof(URL) !== \"undefined\") {\n                try {\n                    var url = new URL(xhr.responseURL);\n                    return url.pathname + url.search;\n                } catch (e) {\n                    triggerErrorEvent(getDocument().body, \"htmx:badResponseUrl\", {url: xhr.responseURL});\n                }\n            }\n        }\n\n        function hasHeader(xhr, regexp) {\n            return xhr.getAllResponseHeaders().match(regexp);\n        }\n\n        function ajaxHelper(verb, path, context) {\n            verb = verb.toLowerCase();\n            if (context) {\n                if (context instanceof Element || isType(context, 'String')) {\n                    return issueAjaxRequest(verb, path, null, null, {\n                        targetOverride: resolveTarget(context),\n                        returnPromise: true\n                    });\n                } else {\n                    return issueAjaxRequest(verb, path, resolveTarget(context.source), context.event,\n                        {\n                            handler : context.handler,\n                            headers : context.headers,\n                            values : context.values,\n                            targetOverride: resolveTarget(context.target),\n                            swapOverride: context.swap,\n                            returnPromise: true\n                        });\n                }\n            } else {\n                return issueAjaxRequest(verb, path, null, null, {\n                        returnPromise: true\n                });\n            }\n        }\n\n        function hierarchyForElt(elt) {\n            var arr = [];\n            while (elt) {\n                arr.push(elt);\n                elt = elt.parentElement;\n            }\n            return arr;\n        }\n\n        function issueAjaxRequest(verb, path, elt, event, etc, confirmed) {\n            var resolve = null;\n            var reject = null;\n            etc = etc != null ? etc : {};\n            if(etc.returnPromise && typeof Promise !== \"undefined\"){\n                var promise = new Promise(function (_resolve, _reject) {\n                    resolve = _resolve;\n                    reject = _reject;\n                });\n            }\n            if(elt == null) {\n                elt = getDocument().body;\n            }\n            var responseHandler = etc.handler || handleAjaxResponse;\n\n            if (!bodyContains(elt)) {\n                return; // do not issue requests for elements removed from the DOM\n            }\n            var target = etc.targetOverride || getTarget(elt);\n            if (target == null || target == DUMMY_ELT) {\n                triggerErrorEvent(elt, 'htmx:targetError', {target: getAttributeValue(elt, \"hx-target\")});\n                return;\n            }\n\n            // allow event-based confirmation w/ a callback\n            if (!confirmed) {\n                var issueRequest = function() {\n                    return issueAjaxRequest(verb, path, elt, event, etc, true);\n                }\n                var confirmDetails = {target: target, elt: elt, path: path, verb: verb, triggeringEvent: event, etc: etc, issueRequest: issueRequest};\n                if (triggerEvent(elt, 'htmx:confirm', confirmDetails) === false) {\n                    return;\n                }\n            }\n\n            var syncElt = elt;\n            var eltData = getInternalData(elt);\n            var syncStrategy = getClosestAttributeValue(elt, \"hx-sync\");\n            var queueStrategy = null;\n            var abortable = false;\n            if (syncStrategy) {\n                var syncStrings = syncStrategy.split(\":\");\n                var selector = syncStrings[0].trim();\n                if (selector === \"this\") {\n                    syncElt = findThisElement(elt, 'hx-sync');\n                } else {\n                    syncElt = querySelectorExt(elt, selector);\n                }\n                // default to the drop strategy\n                syncStrategy = (syncStrings[1] || 'drop').trim();\n                eltData = getInternalData(syncElt);\n                if (syncStrategy === \"drop\" && eltData.xhr && eltData.abortable !== true) {\n                    return;\n                } else if (syncStrategy === \"abort\") {\n                    if (eltData.xhr) {\n                        return;\n                    } else {\n                        abortable = true;\n                    }\n                } else if (syncStrategy === \"replace\") {\n                    triggerEvent(syncElt, 'htmx:abort'); // abort the current request and continue\n                } else if (syncStrategy.indexOf(\"queue\") === 0) {\n                    var queueStrArray = syncStrategy.split(\" \");\n                    queueStrategy = (queueStrArray[1] || \"last\").trim();\n                }\n            }\n\n            if (eltData.xhr) {\n                if (eltData.abortable) {\n                    triggerEvent(syncElt, 'htmx:abort'); // abort the current request and continue\n                } else {\n                    if(queueStrategy == null){\n                        if (event) {\n                            var eventData = getInternalData(event);\n                            if (eventData && eventData.triggerSpec && eventData.triggerSpec.queue) {\n                                queueStrategy = eventData.triggerSpec.queue;\n                            }\n                        }\n                        if (queueStrategy == null) {\n                            queueStrategy = \"last\";\n                        }\n                    }\n                    if (eltData.queuedRequests == null) {\n                        eltData.queuedRequests = [];\n                    }\n                    if (queueStrategy === \"first\" && eltData.queuedRequests.length === 0) {\n                        eltData.queuedRequests.push(function () {\n                            issueAjaxRequest(verb, path, elt, event, etc)\n                        });\n                    } else if (queueStrategy === \"all\") {\n                        eltData.queuedRequests.push(function () {\n                            issueAjaxRequest(verb, path, elt, event, etc)\n                        });\n                    } else if (queueStrategy === \"last\") {\n                        eltData.queuedRequests = []; // dump existing queue\n                        eltData.queuedRequests.push(function () {\n                            issueAjaxRequest(verb, path, elt, event, etc)\n                        });\n                    }\n                    return;\n                }\n            }\n\n            var xhr = new XMLHttpRequest();\n            eltData.xhr = xhr;\n            eltData.abortable = abortable;\n            var endRequestLock = function(){\n                eltData.xhr = null;\n                eltData.abortable = false;\n                if (eltData.queuedRequests != null &&\n                    eltData.queuedRequests.length > 0) {\n                    var queuedRequest = eltData.queuedRequests.shift();\n                    queuedRequest();\n                }\n            }\n            var promptQuestion = getClosestAttributeValue(elt, \"hx-prompt\");\n            if (promptQuestion) {\n                var promptResponse = prompt(promptQuestion);\n                // prompt returns null if cancelled and empty string if accepted with no entry\n                if (promptResponse === null ||\n                    !triggerEvent(elt, 'htmx:prompt', {prompt: promptResponse, target:target})) {\n                    maybeCall(resolve);\n                    endRequestLock();\n                    return promise;\n                }\n            }\n\n            var confirmQuestion = getClosestAttributeValue(elt, \"hx-confirm\");\n            if (confirmQuestion) {\n                if(!confirm(confirmQuestion)) {\n                    maybeCall(resolve);\n                    endRequestLock()\n                    return promise;\n                }\n            }\n\n\n            var headers = getHeaders(elt, target, promptResponse);\n            if (etc.headers) {\n                headers = mergeObjects(headers, etc.headers);\n            }\n            var results = getInputValues(elt, verb);\n            var errors = results.errors;\n            var rawParameters = results.values;\n            if (etc.values) {\n                rawParameters = mergeObjects(rawParameters, etc.values);\n            }\n            var expressionVars = getExpressionVars(elt);\n            var allParameters = mergeObjects(rawParameters, expressionVars);\n            var filteredParameters = filterValues(allParameters, elt);\n\n            if (verb !== 'get' && !usesFormData(elt)) {\n                headers['Content-Type'] = 'application/x-www-form-urlencoded';\n            }\n\n            if (htmx.config.getCacheBusterParam && verb === 'get') {\n                filteredParameters['org.htmx.cache-buster'] = getRawAttribute(target, \"id\") || \"true\";\n            }\n\n            // behavior of anchors w/ empty href is to use the current URL\n            if (path == null || path === \"\") {\n                path = getDocument().location.href;\n            }\n\n\n            var requestAttrValues = getValuesForElement(elt, 'hx-request');\n\n            var eltIsBoosted = getInternalData(elt).boosted;\n            var requestConfig = {\n                boosted: eltIsBoosted,\n                parameters: filteredParameters,\n                unfilteredParameters: allParameters,\n                headers:headers,\n                target:target,\n                verb:verb,\n                errors:errors,\n                withCredentials: etc.credentials || requestAttrValues.credentials || htmx.config.withCredentials,\n                timeout:  etc.timeout || requestAttrValues.timeout || htmx.config.timeout,\n                path:path,\n                triggeringEvent:event\n            };\n\n            if(!triggerEvent(elt, 'htmx:configRequest', requestConfig)){\n                maybeCall(resolve);\n                endRequestLock();\n                return promise;\n            }\n\n            // copy out in case the object was overwritten\n            path = requestConfig.path;\n            verb = requestConfig.verb;\n            headers = requestConfig.headers;\n            filteredParameters = requestConfig.parameters;\n            errors = requestConfig.errors;\n\n            if(errors && errors.length > 0){\n                triggerEvent(elt, 'htmx:validation:halted', requestConfig)\n                maybeCall(resolve);\n                endRequestLock();\n                return promise;\n            }\n\n            var splitPath = path.split(\"#\");\n            var pathNoAnchor = splitPath[0];\n            var anchor = splitPath[1];\n            var finalPathForGet = null;\n            if (verb === 'get') {\n                finalPathForGet = pathNoAnchor;\n                var values = Object.keys(filteredParameters).length !== 0;\n                if (values) {\n                    if (finalPathForGet.indexOf(\"?\") < 0) {\n                        finalPathForGet += \"?\";\n                    } else {\n                        finalPathForGet += \"&\";\n                    }\n                    finalPathForGet += urlEncode(filteredParameters);\n                    if (anchor) {\n                        finalPathForGet += \"#\" + anchor;\n                    }\n                }\n                xhr.open('GET', finalPathForGet, true);\n            } else {\n                xhr.open(verb.toUpperCase(), path, true);\n            }\n\n            xhr.overrideMimeType(\"text/html\");\n            xhr.withCredentials = requestConfig.withCredentials;\n            xhr.timeout = requestConfig.timeout;\n\n            // request headers\n            if (requestAttrValues.noHeaders) {\n                // ignore all headers\n            } else {\n                for (var header in headers) {\n                    if (headers.hasOwnProperty(header)) {\n                        var headerValue = headers[header];\n                        safelySetHeaderValue(xhr, header, headerValue);\n                    }\n                }\n            }\n\n            var responseInfo = {\n                xhr: xhr, target: target, requestConfig: requestConfig, etc: etc, boosted: eltIsBoosted,\n                pathInfo: {\n                    requestPath: path,\n                    finalRequestPath: finalPathForGet || path,\n                    anchor: anchor\n                }\n            };\n\n            xhr.onload = function () {\n                try {\n                    var hierarchy = hierarchyForElt(elt);\n                    responseInfo.pathInfo.responsePath = getPathFromResponse(xhr);\n                    responseHandler(elt, responseInfo);\n                    removeRequestIndicatorClasses(indicators);\n                    triggerEvent(elt, 'htmx:afterRequest', responseInfo);\n                    triggerEvent(elt, 'htmx:afterOnLoad', responseInfo);\n                    // if the body no longer contains the element, trigger the event on the closest parent\n                    // remaining in the DOM\n                    if (!bodyContains(elt)) {\n                        var secondaryTriggerElt = null;\n                        while (hierarchy.length > 0 && secondaryTriggerElt == null) {\n                            var parentEltInHierarchy = hierarchy.shift();\n                            if (bodyContains(parentEltInHierarchy)) {\n                                secondaryTriggerElt = parentEltInHierarchy;\n                            }\n                        }\n                        if (secondaryTriggerElt) {\n                            triggerEvent(secondaryTriggerElt, 'htmx:afterRequest', responseInfo);\n                            triggerEvent(secondaryTriggerElt, 'htmx:afterOnLoad', responseInfo);\n                        }\n                    }\n                    maybeCall(resolve);\n                    endRequestLock();\n                } catch (e) {\n                    triggerErrorEvent(elt, 'htmx:onLoadError', mergeObjects({error:e}, responseInfo));\n                    throw e;\n                }\n            }\n            xhr.onerror = function () {\n                removeRequestIndicatorClasses(indicators);\n                triggerErrorEvent(elt, 'htmx:afterRequest', responseInfo);\n                triggerErrorEvent(elt, 'htmx:sendError', responseInfo);\n                maybeCall(reject);\n                endRequestLock();\n            }\n            xhr.onabort = function() {\n                removeRequestIndicatorClasses(indicators);\n                triggerErrorEvent(elt, 'htmx:afterRequest', responseInfo);\n                triggerErrorEvent(elt, 'htmx:sendAbort', responseInfo);\n                maybeCall(reject);\n                endRequestLock();\n            }\n            xhr.ontimeout = function() {\n                removeRequestIndicatorClasses(indicators);\n                triggerErrorEvent(elt, 'htmx:afterRequest', responseInfo);\n                triggerErrorEvent(elt, 'htmx:timeout', responseInfo);\n                maybeCall(reject);\n                endRequestLock();\n            }\n            if(!triggerEvent(elt, 'htmx:beforeRequest', responseInfo)){\n                maybeCall(resolve);\n                endRequestLock()\n                return promise\n            }\n            var indicators = addRequestIndicatorClasses(elt);\n\n            forEach(['loadstart', 'loadend', 'progress', 'abort'], function(eventName) {\n                forEach([xhr, xhr.upload], function (target) {\n                    target.addEventListener(eventName, function(event){\n                        triggerEvent(elt, \"htmx:xhr:\" + eventName, {\n                            lengthComputable:event.lengthComputable,\n                            loaded:event.loaded,\n                            total:event.total\n                        });\n                    })\n                });\n            });\n            triggerEvent(elt, 'htmx:beforeSend', responseInfo);\n            xhr.send(verb === 'get' ? null : encodeParamsForBody(xhr, elt, filteredParameters));\n            return promise;\n        }\n\n        function determineHistoryUpdates(elt, responseInfo) {\n\n            var xhr = responseInfo.xhr;\n\n            //===========================================\n            // First consult response headers\n            //===========================================\n            var pathFromHeaders = null;\n            var typeFromHeaders = null;\n            if (hasHeader(xhr,/HX-Push:/i)) {\n                pathFromHeaders = xhr.getResponseHeader(\"HX-Push\");\n                typeFromHeaders = \"push\";\n            } else if (hasHeader(xhr,/HX-Push-Url:/i)) {\n                pathFromHeaders = xhr.getResponseHeader(\"HX-Push-Url\");\n                typeFromHeaders = \"push\";\n            } else if (hasHeader(xhr,/HX-Replace-Url:/i)) {\n                pathFromHeaders = xhr.getResponseHeader(\"HX-Replace-Url\");\n                typeFromHeaders = \"replace\";\n            }\n\n            // if there was a response header, that has priority\n            if (pathFromHeaders) {\n                if (pathFromHeaders === \"false\") {\n                    return {}\n                } else {\n                    return {\n                        type: typeFromHeaders,\n                        path : pathFromHeaders\n                    }\n                }\n            }\n\n            //===========================================\n            // Next resolve via DOM values\n            //===========================================\n            var requestPath =  responseInfo.pathInfo.finalRequestPath;\n            var responsePath =  responseInfo.pathInfo.responsePath;\n\n            var pushUrl = getClosestAttributeValue(elt, \"hx-push-url\");\n            var replaceUrl = getClosestAttributeValue(elt, \"hx-replace-url\");\n            var elementIsBoosted = getInternalData(elt).boosted;\n\n            var saveType = null;\n            var path = null;\n\n            if (pushUrl) {\n                saveType = \"push\";\n                path = pushUrl;\n            } else if (replaceUrl) {\n                saveType = \"replace\";\n                path = replaceUrl;\n            } else if (elementIsBoosted) {\n                saveType = \"push\";\n                path = responsePath || requestPath; // if there is no response path, go with the original request path\n            }\n\n            if (path) {\n                // false indicates no push, return empty object\n                if (path === \"false\") {\n                    return {};\n                }\n\n                // true indicates we want to follow wherever the server ended up sending us\n                if (path === \"true\") {\n                    path = responsePath || requestPath; // if there is no response path, go with the original request path\n                }\n\n                // restore any anchor associated with the request\n                if (responseInfo.pathInfo.anchor &&\n                    path.indexOf(\"#\") === -1) {\n                    path = path + \"#\" + responseInfo.pathInfo.anchor;\n                }\n\n                return {\n                    type:saveType,\n                    path: path\n                }\n            } else {\n                return {};\n            }\n        }\n\n        function handleAjaxResponse(elt, responseInfo) {\n            var xhr = responseInfo.xhr;\n            var target = responseInfo.target;\n            var etc = responseInfo.etc;\n\n            if (!triggerEvent(elt, 'htmx:beforeOnLoad', responseInfo)) return;\n\n            if (hasHeader(xhr, /HX-Trigger:/i)) {\n                handleTrigger(xhr, \"HX-Trigger\", elt);\n            }\n\n            if (hasHeader(xhr, /HX-Location:/i)) {\n                saveCurrentPageToHistory();\n                var redirectPath = xhr.getResponseHeader(\"HX-Location\");\n                var swapSpec;\n                if (redirectPath.indexOf(\"{\") === 0) {\n                    swapSpec = parseJSON(redirectPath);\n                    // what's the best way to throw an error if the user didn't include this\n                    redirectPath = swapSpec['path'];\n                    delete swapSpec['path'];\n                }\n                ajaxHelper('GET', redirectPath, swapSpec).then(function(){\n                    pushUrlIntoHistory(redirectPath);\n                });\n                return;\n            }\n\n            if (hasHeader(xhr, /HX-Redirect:/i)) {\n                location.href = xhr.getResponseHeader(\"HX-Redirect\");\n                return;\n            }\n\n            if (hasHeader(xhr,/HX-Refresh:/i)) {\n                if (\"true\" === xhr.getResponseHeader(\"HX-Refresh\")) {\n                    location.reload();\n                    return;\n                }\n            }\n\n            if (hasHeader(xhr,/HX-Retarget:/i)) {\n                responseInfo.target = getDocument().querySelector(xhr.getResponseHeader(\"HX-Retarget\"));\n            }\n\n            var historyUpdate = determineHistoryUpdates(elt, responseInfo);\n\n            // by default htmx only swaps on 200 return codes and does not swap\n            // on 204 'No Content'\n            // this can be ovverriden by responding to the htmx:beforeSwap event and\n            // overriding the detail.shouldSwap property\n            var shouldSwap = xhr.status >= 200 && xhr.status < 400 && xhr.status !== 204;\n            var serverResponse = xhr.response;\n            var isError = xhr.status >= 400;\n            var beforeSwapDetails = mergeObjects({shouldSwap: shouldSwap, serverResponse:serverResponse, isError:isError}, responseInfo);\n            if (!triggerEvent(target, 'htmx:beforeSwap', beforeSwapDetails)) return;\n\n            target = beforeSwapDetails.target; // allow re-targeting\n            serverResponse = beforeSwapDetails.serverResponse; // allow updating content\n            isError = beforeSwapDetails.isError; // allow updating error\n\n            responseInfo.target = target; // Make updated target available to response events\n            responseInfo.failed = isError; // Make failed property available to response events\n            responseInfo.successful = !isError; // Make successful property available to response events\n\n            if (beforeSwapDetails.shouldSwap) {\n                if (xhr.status === 286) {\n                    cancelPolling(elt);\n                }\n\n                withExtensions(elt, function (extension) {\n                    serverResponse = extension.transformResponse(serverResponse, xhr, elt);\n                });\n\n                // Save current page if there will be a history update\n                if (historyUpdate.type) {\n                    saveCurrentPageToHistory();\n                }\n\n                var swapOverride = etc.swapOverride;\n                if (hasHeader(xhr,/HX-Reswap:/i)) {\n                    swapOverride = xhr.getResponseHeader(\"HX-Reswap\");\n                }\n                var swapSpec = getSwapSpecification(elt, swapOverride);\n\n                target.classList.add(htmx.config.swappingClass);\n                var doSwap = function () {\n                    try {\n\n                        var activeElt = document.activeElement;\n                        var selectionInfo = {};\n                        try {\n                            selectionInfo = {\n                                elt: activeElt,\n                                // @ts-ignore\n                                start: activeElt ? activeElt.selectionStart : null,\n                                // @ts-ignore\n                                end: activeElt ? activeElt.selectionEnd : null\n                            };\n                        } catch (e) {\n                            // safari issue - see https://github.com/microsoft/playwright/issues/5894\n                        }\n\n                        var settleInfo = makeSettleInfo(target);\n                        selectAndSwap(swapSpec.swapStyle, target, elt, serverResponse, settleInfo);\n\n                        if (selectionInfo.elt &&\n                            !bodyContains(selectionInfo.elt) &&\n                            selectionInfo.elt.id) {\n                            var newActiveElt = document.getElementById(selectionInfo.elt.id);\n                            var focusOptions = { preventScroll: swapSpec.focusScroll !== undefined ? !swapSpec.focusScroll : !htmx.config.defaultFocusScroll };\n                            if (newActiveElt) {\n                                // @ts-ignore\n                                if (selectionInfo.start && newActiveElt.setSelectionRange) {\n                                    // @ts-ignore\n                                    try {\n                                        newActiveElt.setSelectionRange(selectionInfo.start, selectionInfo.end);\n                                    } catch (e) {\n                                        // the setSelectionRange method is present on fields that don't support it, so just let this fail\n                                    }\n                                }\n                                newActiveElt.focus(focusOptions);\n                            }\n                        }\n\n                        target.classList.remove(htmx.config.swappingClass);\n                        forEach(settleInfo.elts, function (elt) {\n                            if (elt.classList) {\n                                elt.classList.add(htmx.config.settlingClass);\n                            }\n                            triggerEvent(elt, 'htmx:afterSwap', responseInfo);\n                        });\n\n                        if (hasHeader(xhr, /HX-Trigger-After-Swap:/i)) {\n                            var finalElt = elt;\n                            if (!bodyContains(elt)) {\n                                finalElt = getDocument().body;\n                            }\n                            handleTrigger(xhr, \"HX-Trigger-After-Swap\", finalElt);\n                        }\n\n                        var doSettle = function () {\n                            forEach(settleInfo.tasks, function (task) {\n                                task.call();\n                            });\n                            forEach(settleInfo.elts, function (elt) {\n                                if (elt.classList) {\n                                    elt.classList.remove(htmx.config.settlingClass);\n                                }\n                                triggerEvent(elt, 'htmx:afterSettle', responseInfo);\n                            });\n\n                            // if we need to save history, do so\n                            if (historyUpdate.type) {\n                                if (historyUpdate.type === \"push\") {\n                                    pushUrlIntoHistory(historyUpdate.path);\n                                    triggerEvent(getDocument().body, 'htmx:pushedIntoHistory', {path: historyUpdate.path});\n                                } else {\n                                    replaceUrlInHistory(historyUpdate.path);\n                                    triggerEvent(getDocument().body, 'htmx:replacedInHistory', {path: historyUpdate.path});\n                                }\n                            }\n                            if (responseInfo.pathInfo.anchor) {\n                                var anchorTarget = find(\"#\" + responseInfo.pathInfo.anchor);\n                                if(anchorTarget) {\n                                    anchorTarget.scrollIntoView({block:'start', behavior: \"auto\"});\n                                }\n                            }\n\n                            if(settleInfo.title) {\n                                var titleElt = find(\"title\");\n                                if(titleElt) {\n                                    titleElt.innerHTML = settleInfo.title;\n                                } else {\n                                    window.document.title = settleInfo.title;\n                                }\n                            }\n\n                            updateScrollState(settleInfo.elts, swapSpec);\n\n                            if (hasHeader(xhr, /HX-Trigger-After-Settle:/i)) {\n                                var finalElt = elt;\n                                if (!bodyContains(elt)) {\n                                    finalElt = getDocument().body;\n                                }\n                                handleTrigger(xhr, \"HX-Trigger-After-Settle\", finalElt);\n                            }\n                        }\n\n                        if (swapSpec.settleDelay > 0) {\n                            setTimeout(doSettle, swapSpec.settleDelay)\n                        } else {\n                            doSettle();\n                        }\n                    } catch (e) {\n                        triggerErrorEvent(elt, 'htmx:swapError', responseInfo);\n                        throw e;\n                    }\n                };\n\n                if (swapSpec.swapDelay > 0) {\n                    setTimeout(doSwap, swapSpec.swapDelay)\n                } else {\n                    doSwap();\n                }\n            }\n            if (isError) {\n                triggerErrorEvent(elt, 'htmx:responseError', mergeObjects({error: \"Response Status Error Code \" + xhr.status + \" from \" + responseInfo.pathInfo.requestPath}, responseInfo));\n            }\n        }\n\n        //====================================================================\n        // Extensions API\n        //====================================================================\n\n        /** @type {Object<string, import(\"./htmx\").HtmxExtension>} */\n        var extensions = {};\n\n        /**\n         * extensionBase defines the default functions for all extensions.\n         * @returns {import(\"./htmx\").HtmxExtension}\n         */\n        function extensionBase() {\n            return {\n                init: function(api) {return null;},\n                onEvent : function(name, evt) {return true;},\n                transformResponse : function(text, xhr, elt) {return text;},\n                isInlineSwap : function(swapStyle) {return false;},\n                handleSwap : function(swapStyle, target, fragment, settleInfo) {return false;},\n                encodeParameters : function(xhr, parameters, elt) {return null;}\n            }\n        }\n\n        /**\n         * defineExtension initializes the extension and adds it to the htmx registry\n         *\n         * @param {string} name\n         * @param {import(\"./htmx\").HtmxExtension} extension\n         */\n        function defineExtension(name, extension) {\n            if(extension.init) {\n                extension.init(internalAPI)\n            }\n            extensions[name] = mergeObjects(extensionBase(), extension);\n        }\n\n        /**\n         * removeExtension removes an extension from the htmx registry\n         *\n         * @param {string} name\n         */\n        function removeExtension(name) {\n            delete extensions[name];\n        }\n\n        /**\n         * getExtensions searches up the DOM tree to return all extensions that can be applied to a given element\n         *\n         * @param {HTMLElement} elt\n         * @param {import(\"./htmx\").HtmxExtension[]=} extensionsToReturn\n         * @param {import(\"./htmx\").HtmxExtension[]=} extensionsToIgnore\n         */\n         function getExtensions(elt, extensionsToReturn, extensionsToIgnore) {\n\n            if (elt == undefined) {\n                return extensionsToReturn;\n            }\n            if (extensionsToReturn == undefined) {\n                extensionsToReturn = [];\n            }\n            if (extensionsToIgnore == undefined) {\n                extensionsToIgnore = [];\n            }\n            var extensionsForElement = getAttributeValue(elt, \"hx-ext\");\n            if (extensionsForElement) {\n                forEach(extensionsForElement.split(\",\"), function(extensionName){\n                    extensionName = extensionName.replace(/ /g, '');\n                    if (extensionName.slice(0, 7) == \"ignore:\") {\n                        extensionsToIgnore.push(extensionName.slice(7));\n                        return;\n                    }\n                    if (extensionsToIgnore.indexOf(extensionName) < 0) {\n                        var extension = extensions[extensionName];\n                        if (extension && extensionsToReturn.indexOf(extension) < 0) {\n                            extensionsToReturn.push(extension);\n                        }\n                    }\n                });\n            }\n            return getExtensions(parentElt(elt), extensionsToReturn, extensionsToIgnore);\n        }\n\n        //====================================================================\n        // Initialization\n        //====================================================================\n\n        function ready(fn) {\n            if (getDocument().readyState !== 'loading') {\n                fn();\n            } else {\n                getDocument().addEventListener('DOMContentLoaded', fn);\n            }\n        }\n\n        function insertIndicatorStyles() {\n            if (htmx.config.includeIndicatorStyles !== false) {\n                getDocument().head.insertAdjacentHTML(\"beforeend\",\n                    \"<style>\\\n                      .\" + htmx.config.indicatorClass + \"{opacity:0;transition: opacity 200ms ease-in;}\\\n                      .\" + htmx.config.requestClass + \" .\" + htmx.config.indicatorClass + \"{opacity:1}\\\n                      .\" + htmx.config.requestClass + \".\" + htmx.config.indicatorClass + \"{opacity:1}\\\n                    </style>\");\n            }\n        }\n\n        function getMetaConfig() {\n            var element = getDocument().querySelector('meta[name=\"htmx-config\"]');\n            if (element) {\n                // @ts-ignore\n                return parseJSON(element.content);\n            } else {\n                return null;\n            }\n        }\n\n        function mergeMetaConfig() {\n            var metaConfig = getMetaConfig();\n            if (metaConfig) {\n                htmx.config = mergeObjects(htmx.config , metaConfig)\n            }\n        }\n\n        // initialize the document\n        ready(function () {\n            mergeMetaConfig();\n            insertIndicatorStyles();\n            var body = getDocument().body;\n            processNode(body);\n            var restoredElts = getDocument().querySelectorAll(\n                \"[hx-trigger='restored'],[data-hx-trigger='restored']\"\n            );\n            body.addEventListener(\"htmx:abort\", function (evt) {\n                var target = evt.target;\n                var internalData = getInternalData(target);\n                if (internalData && internalData.xhr) {\n                    internalData.xhr.abort();\n                }\n            });\n            window.onpopstate = function (event) {\n                if (event.state && event.state.htmx) {\n                    restoreHistory();\n                    forEach(restoredElts, function(elt){\n                        triggerEvent(elt, 'htmx:restored', {\n                            'document': getDocument(),\n                            'triggerEvent': triggerEvent\n                        });\n                    });\n                }\n            };\n            setTimeout(function () {\n                triggerEvent(body, 'htmx:load', {}); // give ready handlers a chance to load up before firing this event\n            }, 0);\n        })\n\n        return htmx;\n    }\n)()\n}));\n","htmx.defineExtension('debug', {\n    onEvent: function (name, evt) {\n        if (console.debug) {\n            console.debug(name, evt);\n        } else if (console) {\n            console.log(\"DEBUG:\", name, evt);\n        } else {\n            throw \"NO CONSOLE SUPPORTED\"\n        }\n    }\n});\n"]}
